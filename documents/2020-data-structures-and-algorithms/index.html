<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Data Structures and Algorithms</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Data Structures and Algorithms</h1>
</div>
<ul>
<li><a href="#pre-requisite-concepts">Pre-requisite Concepts</a>
<ul>
<li><a href="#asymptotic-runtime-analysis">Asymptotic Runtime Analysis</a>
<ul>
<li><a href="#big-o">Big O</a></li>
<li><a href="#amortized-analysis">Amortized Analysis</a></li>
<li><a href="#logarithmic-runtime">Logarithmic Runtime</a></li>
</ul></li>
<li><a href="#computational-complexity">Computational Complexity</a>
<ul>
<li><a href="#complexity-classes">Complexity Classes</a></li>
<li><a href="#np-problems">NP Problems</a></li>
<li><a href="#reductions">Reductions</a></li>
</ul></li>
<li><a href="#algorithm-design">Algorithm Design</a>
<ul>
<li><a href="#in-place-algorithm">In-place algorithm</a></li>
<li><a href="#spacetime-tradeoff">Space–time tradeoff</a></li>
<li><a href="#heuristics">Heuristics</a></li>
<li><a href="#hash-functions">Hash Functions</a></li>
</ul></li>
</ul></li>
<li><a href="#data-structures-and-adts">Data Structures and ADTs</a>
<ul>
<li><a href="#lists-and-arrays">Lists and Arrays</a>
<ul>
<li><a href="#list">List</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#dynamic-arrays">Dynamic Arrays</a></li>
<li><a href="#linked-lists">Linked Lists</a></li>
<li><a href="#self-organizing-lists">Self-Organizing Lists</a></li>
<li><a href="#skip-lists">Skip Lists</a></li>
</ul></li>
<li><a href="#stacks-and-queues">Stacks and Queues</a>
<ul>
<li><a href="#stacks">Stacks</a></li>
<li><a href="#queues">Queues</a></li>
<li><a href="#priority-queue">Priority Queue</a></li>
</ul></li>
<li><a href="#trees">Trees</a>
<ul>
<li><a href="#binary-heaps">Binary Heaps</a></li>
<li><a href="#tries-prefix-trees">Tries (Prefix Trees)</a></li>
<li><a href="#suffix-treesarrays">Suffix Trees/Arrays</a></li>
<li><a href="#merkle-trees">Merkle Trees</a></li>
<li><a href="#kd-trees">Kd-Trees</a></li>
</ul></li>
<li><a href="#self-balancing-trees">Self-balancing Trees</a>
<ul>
<li><a href="#avl-tree">AVL Tree</a></li>
<li><a href="#redblack-tree">Red–black Tree</a></li>
<li><a href="#b-tree">B-tree</a></li>
</ul></li>
<li><a href="#graphs">Graphs</a></li>
<li><a href="#hash-tables">Hash Tables</a>
<ul>
<li><a href="#dictionaries">Dictionaries</a></li>
<li><a href="#sets">Sets</a></li>
</ul></li>
</ul></li>
<li><a href="#algorithms-and-techniques">Algorithms and Techniques</a>
<ul>
<li><a href="#string-and-array-sorting">String and Array Sorting</a>
<ul>
<li><a href="#binary-search">Binary Search</a></li>
<li><a href="#bubble-sort">Bubble Sort</a></li>
<li><a href="#selection-sort">Selection Sort</a></li>
<li><a href="#insertion-sort">Insertion Sort</a></li>
<li><a href="#merge-sort">Merge Sort</a></li>
<li><a href="#quicksort">QuickSort</a></li>
<li><a href="#heap-sort">Heap Sort</a></li>
<li><a href="#counting-sort">Counting Sort</a></li>
<li><a href="#radix-sort">Radix Sort</a></li>
<li><a href="#timsort">Timsort</a></li>
</ul></li>
<li><a href="#array-analysis-methods">Array Analysis Methods</a>
<ul>
<li><a href="#two-pointer-technique">Two Pointer Technique</a></li>
<li><a href="#fast-and-slow-pointers">Fast and Slow Pointers</a></li>
<li><a href="#sliding-window-technique">Sliding Window Technique</a></li>
<li><a href="#single-pass-with-lookup-table">Single-pass with Lookup Table</a></li>
<li><a href="#range-operations-on-array">Range Operations on Array</a></li>
<li><a href="#kadanes-algorithm">Kadane’s Algorithm</a></li>
</ul></li>
<li><a href="#string-analysis-methods">String Analysis Methods</a>
<ul>
<li><a href="#kmp-pattern-matching">KMP Pattern Matching</a></li>
<li><a href="#rabinkarp">Rabin–Karp</a></li>
<li><a href="#merge-intervals">Merge Intervals</a></li>
</ul></li>
<li><a href="#tree-traversal">Tree Traversal</a></li>
<li><a href="#heap-use-cases">Heap Use Cases</a>
<ul>
<li><a href="#top-k-numbers">Top K Numbers</a></li>
<li><a href="#two-heaps-median-of-data-stream">Two Heaps (Median of Data Stream)</a></li>
</ul></li>
<li><a href="#graph-traversal">Graph Traversal</a>
<ul>
<li><a href="#breadth-first-search">Breadth-First Search</a></li>
<li><a href="#depth-first-search">Depth-First Search</a></li>
<li><a href="#bidirectional-search">Bidirectional Search</a></li>
<li><a href="#dijkstras-algorithm">Dijkstra’s algorithm</a></li>
<li><a href="#a">A*</a></li>
</ul></li>
<li><a href="#graph-analysis-methods">Graph Analysis Methods</a>
<ul>
<li><a href="#topological-sort">Topological Sort</a></li>
</ul></li>
<li><a href="#recursive-problems">Recursive Problems</a>
<ul>
<li><a href="#greedy-algorithms">Greedy Algorithms</a></li>
<li><a href="#backtracking">Backtracking</a></li>
<li><a href="#dynamic-programming-memoization">Dynamic Programming &amp; Memoization</a></li>
</ul></li>
<li><a href="#numerical-problems">Numerical Problems</a>
<ul>
<li><a href="#bit-manipulation">Bit Manipulation</a></li>
</ul></li>
<li><a href="#combinatorial-problems">Combinatorial Problems</a>
<ul>
<li><a href="#permuations">Permuations</a></li>
<li><a href="#combinations">Combinations</a></li>
<li><a href="#n-th-partial-sum">n-th Partial Sum</a></li>
<li><a href="#lattice-paths">Lattice Paths</a></li>
<li><a href="#stars-and-bars">Stars and bars</a></li>
</ul></li>
</ul></li>
</ul>
<h1 id="pre-requisite-concepts">Pre-requisite Concepts</h1>
<h2 id="asymptotic-runtime-analysis">Asymptotic Runtime Analysis</h2>
<h3 id="big-o">Big O</h3>
<p>We can measure the growth rate of the time or space complexity of an algorithm using an upper bound (<span class="math inline">\({\ensuremath{\mathcal{O}}}(f)\)</span>), lower bound ($(f) <span class="math inline">\() or a tight bound (\)</span>(f)$) on the best, worse or average case run time. When analysing an algorithm we typically use an upper bound on the worst case. <span class="math display">\[{\ensuremath{\mathcal{O}}}(1) \leq {\ensuremath{\mathcal{O}}}(\log n) \leq {\ensuremath{\mathcal{O}}}(n) \leq {\ensuremath{\mathcal{O}}}(n \log n) \leq {\ensuremath{\mathcal{O}}}(n^2) \leq  {\ensuremath{\mathcal{O}}}(2^n)  \leq {\ensuremath{\mathcal{O}}}(n!)\]</span></p>
<p><span>2</span></p>
<ul>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span> - constant time</p></li>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}(\log(n))\)</span> - logarithmic time</p></li>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}((\log(n))c)\)</span> - polylogarithmic time</p></li>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span> - linear time</p></li>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}(n^2)\)</span> - quadratic time</p></li>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}(n^c)\)</span> - polynomial time</p></li>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}(c^n)\)</span> - exponential time</p></li>
<li><p><span class="math inline">\({\ensuremath{\mathcal{O}}}(n!)\)</span> - factorial time</p></li>
</ul>
<h3 id="amortized-analysis">Amortized Analysis</h3>
<p>If the cost of an action has high variance, i.e. its computation is often inexpensive but is occasionally expensive, we can capture its expected behaviour using an amortized time value. If we let <span class="math inline">\(T(n)\)</span> represent the amount of work the algorithm does on an input of size <span class="math inline">\(n\)</span>, An operation has amortized cost <span class="math inline">\(T(n)\)</span> if <span class="math inline">\(k\)</span> operations cost <span class="math inline">\(\leq k \cdot T(n)\)</span>. <span class="math inline">\(T(n)\)</span> being amortized roughly means <span class="math inline">\(T(n)\)</span> is averaged over all possible operations.</p>
<p>For example, a dynamic array will copy over elements to an array of double its size whenever an insert is called on an already full instance, otherwise it will simply insert the new element. For <span class="math inline">\(X\)</span> insertions, this happens every <span class="math inline">\(2, 4, 8, ..., X\)</span> insertions. <span class="math display">\[T(n) = {\ensuremath{\mathcal{O}}}( c + \frac{c}{2} + \frac{c}{4} + \cdots) 
        = {\ensuremath{\mathcal{O}}}(2c) 
        = {\ensuremath{\mathcal{O}}}(1)\]</span></p>
<p>A data structure realizing an amortized complexity of <span class="math inline">\({\ensuremath{\mathcal{O}}}(f(n))\)</span> is less performant than one with a worst-case complexity is <span class="math inline">\({\ensuremath{\mathcal{O}}}(f(n))\)</span>, since a very expensive operation might still occur, but it is better than an algorithm with an average-case complexity <span class="math inline">\({\ensuremath{\mathcal{O}}}(f(n))\)</span>, since the amortized bound will achieve this average on any input.</p>
<h3 id="logarithmic-runtime">Logarithmic Runtime</h3>
<p>When encountering an algorithm in which the number of elements in the problem space is halved on each step, i.e. in a divide and conquer solution like binary search, the algorithm will likely have a <span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span> or <span class="math inline">\({\ensuremath{\mathcal{O}}}(n \log n)\)</span> run-time. We can think of <span class="math inline">\({\ensuremath{\mathcal{O}}}(n \log n)\)</span> as doing <span class="math inline">\(\log n\)</span> work <span class="math inline">\(n\)</span> times.</p>
<p>Again, if we let <span class="math inline">\(T(n)\)</span> represent the amount of work the algorithm does on an input of size <span class="math inline">\(n\)</span>, <span class="math display">\[\begin{aligned}
        T(n) &amp;= T(n/2) + \Theta(1) \\
        &amp;=  T(n/4)+ \Theta(1) + \Theta(1) \\ 
        &amp;= \Theta(1) + \cdots + \Theta(1) \\
        &amp;= \Theta(\log n ) 
    \end{aligned}\]</span></p>
<p>When using Python’s standard library sort on an array, we can assume the running time will be <span class="math inline">\({\ensuremath{\mathcal{O}}}(n \log n)\)</span>. See section on Timsort for further details.</p>
<h2 id="computational-complexity">Computational Complexity</h2>
<h3 id="complexity-classes">Complexity Classes</h3>
<p><span class="math display">\[P \subseteq NP \subseteq EXP \subseteq R\]</span></p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(P\)</span>: The set of problems that can be solved in polynomial time.</p></li>
<li><p><span class="math inline">\(NP\)</span>: The set of decision problems that can be solved in non-deterministic polynomial time via a “lucky” algorithm.</p></li>
<li><p><span class="math inline">\(EXP\)</span>: The set of problems that can be solved in exponential time.</p></li>
<li><p><span class="math inline">\(R\)</span>: The set of problems that can be solved in finite time.</p></li>
</ol>
<h3 id="np-problems">NP Problems</h3>
<p>Nondeterminsitic Polynomial (NP) problems follow a nondeterministic model in which an algorithm makes guesses and produce a binary output of YES or NO. These are the simplest interesting class of problems and are known as decision problems. A “lucky” algorithm can make guesses which are always correct without having to attempt all options. In other words, <span class="math inline">\(NP\)</span> is the set of decision problems with solutions that can be verified in polynomial time. This means that when an answer is YES, it can be proved and a polynomial-time algorithm can verify the proof.</p>
<p>P vs. NP asks whether generating proofs of solutions is harder than checking, i.e whether every problem whose solution can be quickly verified can also be solved quickly. NP-hard problems are those at least as hard as all NP problems. NP-hard problems need not be in NP; that is, they may not have solutions verifiable in polynomial time. NP-complete problems are a set of problems to each of which any other NP-problem can be reduced in polynomial time and whose solution may still be verified in polynomial time. In fact, NP-complete = NP <span class="math inline">\(\cap\)</span> NP-hard.</p>
<h3 id="reductions">Reductions</h3>
<p>A reduction is an algorithm for transforming one problem into another problem for which a solution or analysis already exists (instead of solving it from scratch). A sufficiently efficient reduction from one problem to another may be used to show that the second problem is at least as difficult as the first.</p>
<p>NP-complete problems are all interreducible using polynomial-time reductions (same difficulty). This implies that we can use reductions to prove NP-hardness. A one-call reduction is a polynomial time algorithm that constructs an instance of <span class="math inline">\(X\)</span> from an instance <span class="math inline">\(Y\)</span> so that their optimal values are equal, i.e. <span class="math inline">\(X\)</span> problem <span class="math inline">\(\implies\)</span> <span class="math inline">\(Y\)</span> problem <span class="math inline">\(\implies\)</span> <span class="math inline">\(Y\)</span> solution <span class="math inline">\(\implies\)</span> <span class="math inline">\(X\)</span> solution. Multicall reductions instead solve <span class="math inline">\(X\)</span> using free calls to <span class="math inline">\(Y\)</span> — in this sense, every algorithm reduces the problem and model of computation.</p>
<h2 id="algorithm-design">Algorithm Design</h2>
<h3 id="in-place-algorithm">In-place algorithm</h3>
<p>An in-place algorithm is an algorithm which transforms input using no auxiliary data structure, though a small amount of extra storage space is allowed for a constant number of auxiliary variables. The input is usually overwritten by the output (mutated) as the algorithm executes. An in-place algorithm updates input sequence only through replacement or swapping of elements.</p>
<h3 id="spacetime-tradeoff">Space–time tradeoff</h3>
<p>A space–time or time–memory trade-off is a case where an algorithm trades increased space usage with decreased time complexity. Here, space refers to the data storage consumed in performing a given task (RAM, HDD, etc), and time refers to the time consumed in performing a given task (computation time or response time).</p>
<h3 id="heuristics">Heuristics</h3>
<p>A heuristic is a technique designed for solving a problem more quickly when classic methods are too slow, or for finding an approximate solution when classic methods fail to find any exact solution. This is achieved by trading optimality, completeness, accuracy, or precision for speed. In a way, it can be considered a shortcut.</p>
<h3 id="hash-functions">Hash Functions</h3>
<p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. A good hash function satisfies two basic properties: it should be very fast to compute; it should minimize duplication of output values (<strong>collisions</strong>). For many use cases, it is useful for every hash value in the output range to be generated with roughly the same probability. Two of the most common hash algorithms are the MD5 (Message-Digest algorithm 5) and the SHA-1 (Secure Hash Algorithm).</p>
<h1 id="data-structures-and-adts">Data Structures and ADTs</h1>
<p>An <strong>abstract data type (ADT)</strong> is a theoretical model of an entity and the set of operations that can be performed on that entity</p>
<p>A <strong>data structure</strong> is a value in a program which can be used to store and operate on data, i.e. it is a programmed implementation of an ADT.</p>
<p><strong>Contiguously-allocated structures</strong> are composed of single slabs of memory, and include arrays, matrices, heaps, and hash tables.</p>
<p><strong>Linked data structures</strong> are composed of distinct chunks of memory bound together by pointers, and include lists, trees, and graph adjacency lists. Recall, a pointer is a reference to a memory address which stores some data.</p>
<h2 id="lists-and-arrays">Lists and Arrays</h2>
<h3 id="list">List</h3>
<p>A list is an abstract data type that represents a countable number of ordered values, where the same value may occur more than once. Lists are a basic example of containers, as they contain other values. Their operations include the following,</p>
<ul>
<li><p><strong>isEmpty(L)</strong>: test whether or not the list is empty;</p></li>
<li><p><strong>prepend(L, item)</strong>: prepend an entity to the list</p></li>
<li><p><strong>append(L, item)</strong>: append an entity to the list</p></li>
<li><p><strong>get(L, i)</strong>: access the element at a given index.</p></li>
<li><p><strong>head(L)</strong>: determine the first component (head) of the list</p></li>
<li><p><strong>tail(L)</strong>: refer to the list consisting of all the components of a list except for its first (tail).</p></li>
</ul>
<h3 id="arrays">Arrays</h3>
<p>An array is a data structure implementing a list ADT, consisting of a collection of elements (values or variables), each identified by at least one array index or key.</p>
<h3 id="dynamic-arrays">Dynamic Arrays</h3>
<p>A dynamic array is a data structure that allocates all elements contiguously in memory and keeps a count of the current number of elements. If the space reserved for the dynamic array is exceeded, it is reallocated and (possibly) copied, which is an expensive operation.</p>
<h3 id="linked-lists">Linked Lists</h3>
<p>A linked list is a data structure that represents a sequence of nodes. In a singly linked list each node maintains a pointer to the next node in the linked list. A doubly linked list gives each node pointers to both the next node and the previous node. Unlike an array, a linked list does not provide constant time access to a particular “index” within the list, i.e. to access the <span class="math inline">\(K\)</span>th index you will need to iterate through <span class="math inline">\(K\)</span> elements. The benefit of a linked list is that inserting and removing items from the beginning of the list can be done in constant time. For specific applications, this can be useful. Linked structures can have poor cache performance compared with arrays. Maintaining a sorted linked list is costly and not usually worthwhile since we cannot perform binary searches.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> ListNode:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val<span class="op">=</span><span class="dv">0</span>, <span class="bu">next</span><span class="op">=</span><span class="va">None</span>):
        <span class="va">self</span>.val <span class="op">=</span> val
        <span class="va">self</span>.<span class="bu">next</span> <span class="op">=</span> <span class="bu">next</span></code></pre></div>
<h3 id="self-organizing-lists">Self-Organizing Lists</h3>
<p>A self-organizing list is a list that reorders its elements based on some self-organizing heuristic to improve average access time. The aim of a self-organizing list is to improve efficiency of linear search by moving more frequently accessed items towards the head of the list. A self-organizing list achieves near constant time for element access in the best case and uses a reorganizing algorithm to adapt to various query distributions at runtime.</p>
<h3 id="skip-lists">Skip Lists</h3>
<p>As an alternative to balanced trees examined later, a hierarchy of sorted linked lists is maintained, where a random variable is associated to each element to decide whether it gets copied into the next highest list. This implies roughly <span class="math inline">\(\log n\)</span> lists, each roughly half as large as the one above it. A search starts in the smallest list. The search key lies in an interval between two elements, which is then explored in the next larger list. Each searched interval contains an expected constant number of elements per list, for a total expected <span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span> query time. The primary benefits of skip lists are ease of analysis and implementation relative to balanced trees.</p>
<h2 id="stacks-and-queues">Stacks and Queues</h2>
<h3 id="stacks">Stacks</h3>
<p>A stack is an ADT container that uses last-in first-out (LIFO) ordering, i.e. the most recent item added to the stack is the first item to be removed. It supports the following operations:</p>
<ul>
<li><p><strong>pop()</strong>: Remove the top item from the stack.</p></li>
<li><p><strong>push(item)</strong>: Add an item to the top of the stack.</p></li>
<li><p><strong>peek()</strong>: Return the top of the stack.</p></li>
<li><p><strong>isEmpty()</strong>: Return true if and only if the stack is empty.</p></li>
</ul>
<p>Unlike an array, a stack does not offer constant-time access to the <span class="math inline">\(i\)</span>th item. However, it does allow constant time adds and removes as it doesn’t require shifting elements around. One case where stacks are often useful is in certain recursive algorithms where we need to push temporary data onto a stack as we recurse and then remove them as we backtrack (for example, because the recursive check failed). A stack offers an intuitive way to do this. A stack can also be used to implement a recursive algorithm iteratively which is what’s otherwise done in a function’s call stack.</p>
<h3 id="queues">Queues</h3>
<p>A queue is an ADT container that implements FIFO (first-in first-out) ordering, i.e. items are removed in the same order that they are added. It supports the following operations:</p>
<ul>
<li><p><strong>push(item)</strong>: Add an item to the end of the queue.</p></li>
<li><p><strong>popLeft()</strong>: Remove and return the first item in the queue.</p></li>
<li><p><strong>peek()</strong>: Return the top of the queue.</p></li>
<li><p><strong>isEmpty()</strong>: Return true if the queue is empty.</p></li>
</ul>
<p>One place where queues are often used is in breadth-first search or in implementing a cache. In breadth-first search we may use a queue to store a list of the nodes that we need to process. Each time we process a node, we add its adjacent nodes to the back of the queue. This allows us to process nodes in the order in which they are viewed.</p>
<p>A queue can be implemented with a linked list and moreover, they are essentially the same thing as long as items are added and removed from opposite sides.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Using a list </span>
q <span class="op">=</span> []
<span class="cf">for</span> item <span class="op">in</span> data:
    q.append(item) 

<span class="cf">while</span> <span class="bu">len</span>(q):
    next_item <span class="op">=</span> queue.pop(<span class="dv">0</span>)
    <span class="bu">print</span>(next_item)

<span class="co"># The collections.deque module </span>
<span class="im">from</span> collections <span class="im">import</span> deque 

q <span class="op">=</span> deque() 
<span class="cf">for</span> item <span class="op">in</span> data:
    q.append(item) 
 
<span class="cf">while</span> <span class="bu">len</span>(q):
    next_item <span class="op">=</span> q.popleft() 
    <span class="bu">print</span>(next_item)</code></pre></div>
<h3 id="priority-queue">Priority Queue</h3>
<p>A priority queue is an ADT container that retrieves items not by the insertion time (as in a stack or queue), nor by a key match (as in a dictionary), but instead retrieves items with the highest priority value. Priority queues provide more flexibility than simple sorting because they allow new elements to enter a system at arbitrary intervals. It is much more cost-effective to insert a new job into a priority queue than to re-sort everything on each such arrival. The basic priority queue supports three primary operations:</p>
<ul>
<li><p><strong>insert(Q, x)</strong>: Given an item x with key k, insert it into the priority queue Q.</p></li>
<li><p><strong>findMinimum(Q)</strong> or <strong>findMaximum(Q)</strong>: Return a pointer to the item whose key value is smaller (larger) than any other key in the priority queue Q.</p></li>
<li><p><strong>deleteMinimum(Q)</strong> or <strong>deleteMaximum(Q)</strong>: Remove the item from the priority queue Q whose key is minimum (maximum).</p></li>
</ul>
<p>There are several choices in which underlying data structures can be used for a basic priority queue implementation:</p>
<ol style="list-style-type: decimal">
<li><p>Sorted arrays are very efficient in both identifying the smallest element and deleting it by decrementing the top index. However, maintaining the total order makes inserting new elements slow. Sorted arrays are only suitable when there will be few insertions into the priority queue.</p></li>
<li><p>Binary heaps are the right answer when the upper bound on the number of items in your priority queue is known, since you must specify array size at creation time. Though this constraint can be mitigated by using dynamic arrays</p></li>
<li><p>Bounded height priority queue</p></li>
<li><p>Binary search trees make effective priority queues, since the smallest element is always the leftmost leaf, while the largest element is always the rightmost leaf. The min (max) is found by simply tracing down left (right) pointers until the next pointer is nil. Binary tree heaps prove most appropriate when you need other dictionary operations, or if you have an unbounded key range and do not know the maximum priority queue size in advance.</p></li>
<li><p>Fibonacci and pairing heaps. These complicated priority queues are designed to speed up decrease-key operations, where the priority of an item already in the priority queue is reduced. This arises, for example, in shortest path computations when we discover a shorter route to a vertex v than previously established.</p></li>
</ol>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># The queue module</span>
<span class="im">from</span> Queue <span class="im">import</span> PriorityQueue

q <span class="op">=</span> PriorityQueue()
<span class="cf">for</span> item <span class="op">in</span> data:
    q.put((item.priority, item))

<span class="cf">while</span> <span class="op">not</span> q.empty():
    next_item <span class="op">=</span> q.get()
    <span class="bu">print</span>(next_item)

<span class="co"># The heapq module</span>
<span class="im">import</span> heapq

q <span class="op">=</span> []
<span class="cf">for</span> item <span class="op">in</span> data:
    heapq.heappush(q, (item.priority, item))

<span class="cf">while</span> q:
    next_item <span class="op">=</span> heapq.heappop(q)
    <span class="bu">print</span>(next_item)</code></pre></div>
<h2 id="trees">Trees</h2>
<p>A tree is an ADT composed of nodes such that there is a root node with zero or more child nodes where each child node also has zero or more child nodes and can be recursively defined as a root node of a sub-tree. Since there are no edges between sibling nodes, a tree cannot contain cycles. Furthermore, nodes can be given a particular order, can have any data type as values, and they may or may not have links back to their parent nodes.</p>
<p>A <strong>binary tree</strong> is a tree in which each node has up to two children. A <strong>binary search tree</strong> is a binary tree in which every node <span class="math inline">\(n\)</span> follows a specific ordering property: all left descendants <span class="math inline">\(\leq n &lt;\)</span> all right descendants. A <strong>complete</strong> binary tree is a binary tree in which every level of the tree is filled, except for perhaps the last level and all of the nodes in the bottom level are as far to the left as possible. A <strong>full</strong> binary tree is a binary tree in which every node has either zero or two children. A <strong>perfect</strong> binary tree is one that is both full and complete.</p>
<p>A complete tree with <span class="math inline">\(n\)</span> nodes has <span class="math inline">\(\lceil \log n \rceil\)</span> height. There is no ambiguity about where the ”empty“ spots in a complete tree are so we do not need to use up space to store references between nodes, as we do in a standard binary tree implementation. This means that we can store its nodes inside an array. For a node corresponding to index <span class="math inline">\(i\)</span>, its left child is stored at index <span class="math inline">\(2i\)</span>, and its right child is stored at index <span class="math inline">\(2i + 1\)</span>. Going backwards, we can also deduce that the parent of index <span class="math inline">\(i\)</span> (when <span class="math inline">\(i &gt; 1\)</span>) is stored at index <span class="math inline">\(\lceil i/2 \rceil\)</span>.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Generic tree</span>
<span class="im">from</span> collections <span class="im">import</span> defaultdict

<span class="co">## a tree is a dict whose default values are trees. </span>
tree <span class="op">=</span> <span class="kw">lambda</span>: defaultdict(tree)

<span class="co"># Object-oriented binary tree</span>
<span class="kw">class</span> TreeNode:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val<span class="op">=</span><span class="dv">0</span>, left<span class="op">=</span><span class="va">None</span>, right<span class="op">=</span><span class="va">None</span>):
        <span class="va">self</span>.val <span class="op">=</span> val
        <span class="va">self</span>.left <span class="op">=</span> left
        <span class="va">self</span>.right <span class="op">=</span> right</code></pre></div>
<h3 id="binary-heaps">Binary Heaps</h3>
<p>The <strong>heap property</strong> states that the key stored in each node is either greater than or equal to or less than or equal to the keys in the node’s children, according to some total order. A <strong>min-heap</strong> is a complete binary tree (filled other than the rightmost elements on the last level) where each node is smaller than its children. The root, therefore, is the minimum element in the tree. The converse holds for a <strong>max-heap</strong>. We have two key operations on a heap:</p>
<ul>
<li><p><strong>insert(x)</strong>: When we insert into a min-heap, we always start by inserting the element at the bottom. We insert at the rightmost spot so as to maintain the complete tree property. Then, we maintain the heap property by swapping the new element with its parent until we find an appropriate spot for the element. We essentially bubble up the minimum element. This takes <span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span> time, where <span class="math inline">\(n\)</span> is the number of nodes in the heap.</p></li>
<li><p><strong>findMin()</strong> or <strong>findMax()</strong>: Finding the minimum element of a min-heap is inexpensive since it will always be at the top. The challenging part is how to remove it while maintaining the heap property. First, we remove the minimum element and swap it with the last element in the heap (the bottommost, rightmost element). Then, we bubble down this element, swapping it with one of its children until the minheap property is restored. This algorithm will also take <span class="math inline">\({\ensuremath{\mathcal{O}}}( \log n)\)</span> time.</p></li>
</ul>
<p>A heap will be better at findMin/findMax (<span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span>), while a BST is performant at all finds (<span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span>). A heap is especially good at basic ordering and keeping track of max and mins.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Using heapq module</span>
<span class="im">import</span> heapq

listForTree <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>]    

<span class="co">## min heap</span>
heapq.heapify(listForTree)            
heapq.heappop(minheap)      

<span class="kw">class</span> MinHeap(<span class="bu">object</span>):
  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>): <span class="va">self</span>.h <span class="op">=</span> []
  <span class="kw">def</span> heappush(<span class="va">self</span>, x): heapq.heappush(<span class="va">self</span>.h, x)
  <span class="kw">def</span> heappop(<span class="va">self</span>): <span class="cf">return</span> heapq.heappop(<span class="va">self</span>.h)
  <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, i): <span class="cf">return</span> <span class="va">self</span>.h[i]
  <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>): <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.h)

<span class="co">## max heap</span>
heapq._heapify_max(listForTree)       
heapq._heappop_max(maxheap) 

<span class="kw">class</span> MaxHeapObj(<span class="bu">object</span>):
  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val): <span class="va">self</span>.val <span class="op">=</span> val
  <span class="kw">def</span> <span class="fu">__lt__</span>(<span class="va">self</span>, other): 
    <span class="co">&quot;&quot;&quot;Invert comparison logic&quot;&quot;&quot;</span>
    <span class="cf">return</span> <span class="va">self</span>.val <span class="op">&gt;</span> other.val
  
<span class="kw">class</span> MaxHeap(MinHeap):
  <span class="kw">def</span> heappush(<span class="va">self</span>, x): heapq.heappush(<span class="va">self</span>.h, MaxHeapObj(x))
  <span class="kw">def</span> heappop(<span class="va">self</span>): <span class="cf">return</span> heapq.heappop(<span class="va">self</span>.h).val
  <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, i): <span class="cf">return</span> <span class="va">self</span>.h[i].val


<span class="co"># Max heap full implementation</span>
<span class="kw">class</span> MaxHeap:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, items<span class="op">=</span>[]):
        <span class="va">self</span>.heap <span class="op">=</span> [<span class="dv">0</span>]
        <span class="cf">for</span> i <span class="op">in</span> items:
            <span class="va">self</span>.heap.append(i)
            <span class="va">self</span>.__floatUp(<span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">-</span> <span class="dv">1</span>)

    <span class="kw">def</span> push(<span class="va">self</span>, data):
        <span class="va">self</span>.heap.append(data)
        <span class="va">self</span>.__floatUp(<span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">-</span> <span class="dv">1</span>)

    <span class="kw">def</span> peek(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.heap[<span class="dv">1</span>]:
            <span class="cf">return</span> <span class="va">self</span>.heap[<span class="dv">1</span>]
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">False</span>

    <span class="kw">def</span> pop(<span class="va">self</span>):
        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">&gt;</span> <span class="dv">2</span>:
            <span class="va">self</span>.__swap(<span class="dv">1</span>, <span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">-</span> <span class="dv">1</span>)
            maxVal <span class="op">=</span> <span class="va">self</span>.heap.pop()
            <span class="va">self</span>.__bubbleDown(<span class="dv">1</span>)
        <span class="cf">elif</span> <span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">==</span> <span class="dv">2</span>:
            maxVal <span class="op">=</span> <span class="va">self</span>.heap.pop()
        <span class="cf">else</span>:
            maxVal <span class="op">=</span> <span class="va">False</span>
        <span class="cf">return</span> maxVal

    <span class="kw">def</span> __swap(<span class="va">self</span>, i, j):
        <span class="va">self</span>.heap[i], <span class="va">self</span>.heap[j] <span class="op">=</span> <span class="va">self</span>.heap[j], <span class="va">self</span>.heap[i]

    <span class="kw">def</span> __floatUp(<span class="va">self</span>, index):
        parent <span class="op">=</span> index<span class="op">//</span><span class="dv">2</span>
        <span class="cf">if</span> index <span class="op">&lt;=</span> <span class="dv">1</span>:
            <span class="cf">return</span>
        <span class="cf">elif</span> <span class="va">self</span>.heap[index] <span class="op">&gt;</span> <span class="va">self</span>.heap[parent]:
            <span class="va">self</span>.__swap(index, parent)
            <span class="va">self</span>.__floatUp(parent)

    <span class="kw">def</span> __bubbleDown(<span class="va">self</span>, index):
        left <span class="op">=</span> index <span class="op">*</span> <span class="dv">2</span>
        right <span class="op">=</span> index <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>
        largest <span class="op">=</span> index
        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">&gt;</span> left <span class="op">and</span> <span class="va">self</span>.heap[largest] <span class="op">&lt;</span> <span class="va">self</span>.heap[left]:
            largest <span class="op">=</span> left
        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">&gt;</span> right <span class="op">and</span> <span class="va">self</span>.heap[largest] <span class="op">&lt;</span> <span class="va">self</span>.heap[right]:
            largest <span class="op">=</span> right
        <span class="cf">if</span> largest <span class="op">!=</span> index:
            <span class="va">self</span>.__swap(index, largest)
            <span class="va">self</span>.__bubbleDown(largest)</code></pre></div>
<h3 id="tries-prefix-trees">Tries (Prefix Trees)</h3>
<p>A trie is a variant of an n-ary tree in which alphanumeric characters are stored at each node. Each path down the tree may represent a word. The * nodes (sometimes called “null nodes&quot;) are often used to indicate complete words. The actual implementation of these * nodes might be a special type of child (such as a TerminatingTrieNode, which inherits from TrieNode). Or, we could use just a boolean flag terminates within the “parent&quot; node. A node in a trie could have anywhere from 1 through ALPHABET_SIZE + 1 children (or, 0 through ALPHABET_SIZE if a boolean flag is used instead of a * node).</p>
<p>Very commonly, a trie is used to store the entire (English) language for quick prefix lookups. A trie can check if a string is a valid prefix in <span class="math inline">\({\ensuremath{\mathcal{O}}}(K)\)</span> time, where <span class="math inline">\(K\)</span> is the length of the string. Many problems involving lists of valid words leverage a trie as an optimization.</p>
<p>Observe that most of the nodes in a trie-based suffix tree occur on simple paths between branch nodes in the tree. Each of these simple paths corresponds to a substring of the original string. By storing the original string in an array and collapsing each such path into a single edge, we have all the information of the full suffix tree in only <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span> space. The label for each edge is described by the starting and ending array indices representing the substring. Some example use cases are as follows:</p>
<ul>
<li><p>Find all occurrences of <span class="math inline">\(q\)</span> as a substring of <span class="math inline">\(S\)</span>: In collapsed suffix trees, it takes <span class="math inline">\({\ensuremath{\mathcal{O}}}(|q| + k)\)</span> time to find the <span class="math inline">\(k\)</span> occurrences of <span class="math inline">\(q\)</span> in <span class="math inline">\(S\)</span>.</p></li>
<li><p>Longest substring common to a set of strings</p></li>
<li><p>Find the longest palindrome in <span class="math inline">\(S\)</span></p></li>
</ul>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> collections

<span class="kw">class</span> TrieNode:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="va">self</span>.word <span class="op">=</span> <span class="va">False</span>
        <span class="va">self</span>.children <span class="op">=</span> {}

<span class="kw">class</span> Trie:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="va">self</span>.root <span class="op">=</span> TrieNode()

    <span class="kw">def</span> insert(<span class="va">self</span>, word):
        node <span class="op">=</span> <span class="va">self</span>.root
        <span class="cf">for</span> char <span class="op">in</span> word:
            <span class="cf">if</span> char <span class="op">not</span> <span class="op">in</span> node.children:
                node.children[char] <span class="op">=</span> TrieNode()
            node <span class="op">=</span> node.children[char]
        node.word <span class="op">=</span> <span class="va">True</span>

    <span class="kw">def</span> search(<span class="va">self</span>, word):
        node <span class="op">=</span> <span class="va">self</span>.root
        <span class="cf">for</span> char <span class="op">in</span> word:
            <span class="cf">if</span> char <span class="op">not</span> <span class="op">in</span> node.children:
                <span class="cf">return</span> <span class="va">False</span>
            node <span class="op">=</span> node.children[char]
        <span class="cf">return</span> node.word

    <span class="kw">def</span> startsWith(<span class="va">self</span>, prefix):
        node <span class="op">=</span> <span class="va">self</span>.root
        <span class="cf">for</span> char <span class="op">in</span> prefix:
            <span class="cf">if</span> char <span class="op">not</span> <span class="op">in</span> node.children:
                <span class="cf">return</span> <span class="va">False</span>
            node <span class="op">=</span> node.children[char]
        <span class="cf">return</span> <span class="va">True</span></code></pre></div>
<h3 id="suffix-treesarrays">Suffix Trees/Arrays</h3>
<p>A special kind of trie, called a suffix tree, can be used to index all suffixes in a text in order to carry out fast full text searches. The construction of such a tree for the string <span class="math inline">\(S\)</span> takes linear time and space relative to the length of <span class="math inline">\(S\)</span>. Once constructed, several operations can be performed quickly, i.e. locating a substring in <span class="math inline">\(S\)</span>, locating a substring if a certain number of mistakes or edits are allowed, locating matches for a regular expression pattern etc. Suffix trees also provide one of the first linear-time solutions for the longest common substring problem. Though these speedups come at a cost: storing a string’s suffix tree typically requires significantly more space than storing the string itself.</p>
<p>The suffix tree for the string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span> is defined as a tree such that:</p>
<ol style="list-style-type: decimal">
<li><p>The tree has exactly <span class="math inline">\(n\)</span> leaves numbered from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>.</p></li>
<li><p>Except for the root, every internal node has at least two children.</p></li>
<li><p>Each edge is labelled with a non-empty substring of <span class="math inline">\(S\)</span>.</p></li>
<li><p>No two edges starting out of a node can have string-labels beginning with the same character.</p></li>
<li><p>The string obtained by concatenating all the string-labels found on the path from the root to leaf <span class="math inline">\(i\)</span> spells out suffix <span class="math inline">\(S[i \cdots n]\)</span>, for <span class="math inline">\(i\)</span> from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>.</p></li>
</ol>
<p>Suffix arrays do most of what suffix trees do, while using roughly four times less memory. They are also easier to implement. A suffix array is, in principle, just an array that contains all the <span class="math inline">\(n\)</span> suffixes of <span class="math inline">\(S\)</span> in sorted order. Thus a binary search of this array for string <span class="math inline">\(q\)</span> suffices to locate the prefix of a suffix that matches <span class="math inline">\(q\)</span>, permitting an efficient substring search in <span class="math inline">\(O(\log n)\)</span> string comparisons. With the addition of an index specifying the common prefix length of all bounding suffixes, only <span class="math inline">\(\log n+|q|\)</span> character comparisons need be performed on any query, since we can identify the next character that must be tested in the binary search.</p>
<p>In a suffix array, a suffix is represented completely by its unique starting position (from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>) and read off as needed using a single reference copy of the input string. Some care must be taken to construct suffix arrays efficiently, however, since there are <span class="math inline">\(O(n^2)\)</span> characters in the strings being sorted. One solution is to first build a suffix tree, then perform an in-order traversal of it to read the strings off in sorted order. However, more recent breakthroughs have lead to space/time efficient algorithms for constructing suffix arrays directly.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> itertools <span class="im">import</span> zip_longest, islice

<span class="kw">def</span> to_int_keys(l):
    <span class="co">&quot;&quot;&quot;</span>
<span class="co">    l: iterable of keys</span>
<span class="co">    returns: a list with integer keys</span>
<span class="co">    &quot;&quot;&quot;</span>
    seen <span class="op">=</span> <span class="bu">set</span>()
    ls <span class="op">=</span> []
    <span class="cf">for</span> e <span class="op">in</span> l:
        <span class="cf">if</span> <span class="op">not</span> e <span class="op">in</span> seen:
            ls.append(e)
            seen.add(e)
    ls.sort()
    index <span class="op">=</span> {v: i <span class="cf">for</span> i, v <span class="op">in</span> <span class="bu">enumerate</span>(ls)}
    <span class="cf">return</span> [index[v] <span class="cf">for</span> v <span class="op">in</span> l]

<span class="kw">def</span> suffix_array(s):
    <span class="co">&quot;&quot;&quot;</span>
<span class="co">    suffix array of s</span>
<span class="co">    O(n * log(n)^2)</span>
<span class="co">    &quot;&quot;&quot;</span>
    n <span class="op">=</span> <span class="bu">len</span>(s)
    k <span class="op">=</span> <span class="dv">1</span>
    line <span class="op">=</span> to_int_keys(s)
    <span class="cf">while</span> <span class="bu">max</span>(line) <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span>:
        line <span class="op">=</span> to_int_keys_best(
            [a <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> b <span class="op">+</span> <span class="dv">1</span>
             <span class="cf">for</span> (a, b) <span class="op">in</span>
             zip_longest(line, islice(line, k, <span class="va">None</span>),
                         fillvalue<span class="op">=-</span><span class="dv">1</span>)])
        k <span class="op">&lt;&lt;=</span> <span class="dv">1</span>
    <span class="cf">return</span> line</code></pre></div>
<h3 id="merkle-trees">Merkle Trees</h3>
<p>A <strong>hash tree</strong> or Merkle tree is a tree in which every leaf node is labelled with the cryptographic hash of a data block, and every non-leaf node is labelled with the cryptographic hash of the labels of its child nodes. Hash trees allow efficient and secure verification of the contents of large data structures. Hash trees are a generalization of hash lists and hash chains.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> hashlib <span class="im">import</span> sha256

<span class="kw">def</span> hash_(x):
    S <span class="op">=</span> sha256()
    S.update(x)
    <span class="cf">return</span> S.hexdigest()

<span class="kw">def</span> merkle(node):
    <span class="cf">if</span> <span class="op">not</span> node:
        <span class="cf">return</span> <span class="st">&#39;#&#39;</span>
    m_left <span class="op">=</span> merkle(node.left)
    m_right <span class="op">=</span> merkle(node.right)
    node.merkle <span class="op">=</span> hash_(m_left <span class="op">+</span> <span class="bu">str</span>(node.val) <span class="op">+</span> m_right)
    <span class="cf">return</span> node.merkle

<span class="co"># Two trees are identical if the hash of their roots are equal (except for collisions)</span>
<span class="kw">def</span> isSubtree(s, t):
    merkle(s)
    merkle(t)
    
    <span class="kw">def</span> dfs(node):
        <span class="cf">if</span> <span class="op">not</span> node:
            <span class="cf">return</span> <span class="va">False</span>
        <span class="cf">return</span> (node.merkle <span class="op">==</span> t.merkle <span class="op">or</span>
                dfs(node.left) <span class="op">or</span> dfs(node.right))

    <span class="cf">return</span> dfs(s)</code></pre></div>
<h3 id="kd-trees">Kd-Trees</h3>
<p>Kd-trees and related spatial data structures hierarchically decompose space into a small number of cells, each containing a few representatives from an input set of points. This provides a fast way to access any object by position. We traverse down the hierarchy until we find the smallest cell containing it, and then scan through the objects in this cell to identify the right one.</p>
<p>Typical algorithms construct kd-trees by partitioning point sets. Ideally, this plane equally partitions the subset of points into left/right (or up/down) subsets. Partitioning stops after <span class="math inline">\(\log n\)</span> levels, with each point in its own leaf cell. Each box-shaped region is defined by <span class="math inline">\(2k\)</span> planes, where <span class="math inline">\(k\)</span> is the number of dimensions. Useful applications are as follows:</p>
<ul>
<li><p>Point location – To identify which cell a query point <span class="math inline">\(q\)</span> lies in, we start at the root and test which side of the partition plane contains <span class="math inline">\(q\)</span>.</p></li>
<li><p>Nearest neighbor search – To find the point in <span class="math inline">\(S\)</span> closest to a query point <span class="math inline">\(q\)</span>, we perform point location to find the cell <span class="math inline">\(c\)</span> containing <span class="math inline">\(q\)</span></p></li>
<li><p>Range search – Which points lie within a query box or region? Starting from the root, check whether the query region intersects (or contains) the cell defining the current node. If it does, check the children; if not, none of the leaf cells below this node can possibly be of interest.</p></li>
<li><p>Partial key search – Suppose we want to find a point p in S, but we do not have full information about p. Say we are looking for someone of age 35 and height 5’8” but of unknown weight in a 3D-tree with dimensions of age, weight, and height. Starting from the root, we can identify the correct descendant for all but the weight dimension</p></li>
</ul>
<p>Kd-trees are most useful for a small to moderate number of dimensions, say from 2 up to maybe 20 dimensions. Algorithms that quickly produce a point provably close to the query point are a recent development in higher-dimensional nearest neighbor search. A sparse weighted graph structure is built from the data set, and the nearest neighbor is found by starting at a random point and walking greedily in the graph towards the query point.</p>
<h2 id="self-balancing-trees">Self-balancing Trees</h2>
<p>Balanced search trees use local <strong>rotation operations</strong> to restructure search trees, moving more distant nodes closer to the root while maintaining the in-order search structure of the tree. The <strong>balance factor</strong> of a node in a binary tree is the height of its right subtree minus the height of its left subtree.</p>
<p>Among balanced search trees, AVL and 2/3 trees are now considered out-dated while red-black trees seem to be more popular. A particularly interesting self-organizing data structure is the splay tree, which uses rotations to move any accessed key to the root. Frequently used or recently accessed nodes thus sit near the top of the tree, allowing faster searches</p>
<h3 id="avl-tree">AVL Tree</h3>
<p>An AVL tree is a self-balancing binary search tree. A node satisfies the <strong>AVL invariant</strong> if its balance factor is between -1 and 1. A binary tree is AVL-balanced if all of its nodes satisfy the AVL invariant, so we can say that an AVL tree is a binary search tree which is AVL-balanced.</p>
<p>To maintain the AVL condition, perform an insertion/deletion using the typical BST algorithm, then if any nodes have the balance factor invariant violated, restore the invariant. We can simply do so after the recursive Insert, Delete, ExtractMax, or ExtractMin call. So we go down the tree to search for the correct spot to insert the node, and then go back up the tree to restore the AVL invariant. In fact, these restrictions make it straightforward to define a small set of simple, constant-time procedures to restructure the tree to restore the balance factor in these cases. These procedures are called rotations.</p>
<p>The worst-case running time of AVL tree insertion and deletion is <span class="math inline">\({\ensuremath{\mathcal{O}}}(h)\)</span>, where <span class="math inline">\(h\)</span> is the height of the tree, the same as for the naive insertion and deletion algorithms. An AVL tree with <span class="math inline">\(n\)</span> nodes has height at most <span class="math inline">\(1.44 \log n\)</span>. AVL tree insertion, deletion, and search have worst-case running time <span class="math inline">\(\Theta(\log n)\)</span>, where <span class="math inline">\(n\)</span> is the number of nodes in the tree</p>
<h3 id="redblack-tree">Red–black Tree</h3>
<p>A red–black tree is a kind of self-balancing binary search tree. Each node of the binary tree has an extra bit which is often interpreted as the color (red or black) of the node. These color bits are used to ensure the tree remains approximately balanced during insertions and deletions.</p>
<p>Balance is preserved by painting each node of the tree with one of two colors in a way that satisfies certain properties, which collectively constrain how unbalanced the tree can become in the worst case. When the tree is modified, the new tree is subsequently rearranged and repainted to restore the coloring properties. The properties are designed in such a way that this rearranging and recoloring can be performed efficiently. The balancing of the tree is not perfect, but it is good enough to allow it to guarantee searching in <span class="math inline">\(O(\log n)\)</span> time.</p>
<p>Properties:</p>
<ol style="list-style-type: decimal">
<li><p>Each node is either red or black.</p></li>
<li><p>The root is black. This rule is sometimes omitted. Since the root can always be changed from red to black, but not necessarily vice versa, this rule has little effect on analysis.</p></li>
<li><p>All leaves (NIL) are black.</p></li>
<li><p>If a node is red, then both its children are black.</p></li>
<li><p>Every path from a given node to any of its descendant NIL nodes goes through the same number of black nodes.</p></li>
</ol>
<h3 id="b-tree">B-tree</h3>
<p>A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time (<span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span>). The B-tree generalizes the binary search tree, allowing for nodes with more than two children and multiple keys. It is commonly used in databases and file systems.</p>
<p>The idea behind a B-tree is to collapse several levels of a binary search tree into a single large node, so that we can make the equivalent of several search steps before another disk access is needed. With B-trees we can access enormous numbers of keys using only a few disk accesses. To get the full benefit from using a B-tree, it is important to understand how the secondary storage device and virtual memory interact, through constants such as page size and virtual/real address space. Cache-oblivious algorithms can mitigate such concerns.</p>
<p>A B-tree of order <span class="math inline">\(m\)</span> is a tree which satisfies the following properties:</p>
<ol style="list-style-type: decimal">
<li><p>The root has at least two children if it is not a leaf node.</p></li>
<li><p>Every non-leaf node (except the root) has at least $  $ child nodes.</p></li>
<li><p>All leaves appear in the same level and carry no information.</p></li>
<li><p>Every node has at most <span class="math inline">\(m\)</span> children.</p></li>
<li><p>A non-leaf node with <span class="math inline">\(k\)</span> children contains <span class="math inline">\(k-1\)</span> keys.</p></li>
</ol>
<p>B-trees are constructed in a bottom-up way: values are inserted into a node based on binary search. If the node reaches its capacity based on the degree of the B-tree, then it is split in half with left or bias and an appropriate root (median value) and children are selected and appointed to existing or new nodes.</p>
<p>For implementing multi-level indexing in a database, every node will have a key to be indexed by, a pointer to its child nodes in their memory blocks as well as a pointer to a record on the database (value).</p>
<p>In a <strong>B+ tree</strong>, only leaf nodes contain a record pointer with leaf nodes also containing a copy of corresponding parent keys.</p>
<h2 id="graphs">Graphs</h2>
<p>A graph is simply a collection of nodes, some of which may have edges between them. With this definition, we see that a tree is a connected graph that does not have cycles. Graphs can be either <strong>directed</strong> or <strong>undirected</strong>. A graph might consist of multiple isolated subgraphs. If there is a path between every pair of vertices, it is called a <strong>connected</strong> graph. A graph can also have cycles (or not), an <strong>acyclic</strong> graph is one without cycles.</p>
<p>There are two common ways to represent a graph: <strong>adjacency lists</strong> and <strong>adjacency matrices</strong>. Every vertex (or node) stores a list of adjacent vertices. In an undirected graph, an edge like (a, b) would be stored twice: once in a’s adjacent vertices and once in b’s adjacent vertices. An adjacency matrix is an NxN boolean matrix (where N is the number of nodes), where a true value at matrix [i] [j] indicates an edge from node i to node j. (You can also use an integer matrix with Os and 1 s.) In an undirected graph, an adjacency matrix will be symmetric. In a directed graph, it will not (necessarily) be.</p>
<ol style="list-style-type: decimal">
<li><p>How big will your graph be? – Adjacency matrices make sense only for small or very dense graphs.</p></li>
<li><p>How dense will your graph be? –– If your graph is very dense, meaning that a large fraction of the vertex pairs define edges, there is probably no compelling reason to use adjacency lists. You will be doomed to using <span class="math inline">\(\Theta(n^2)\)</span> space anyway. Indeed, for complete graphs, matrices will be more concise due to the elimination of pointers.</p></li>
<li><p>Which algorithms will you be implementing? – Certain algorithms are more natural on adjacency matrices (such as all-pairs shortest path) and others favor adjacency lists (such as most DFS-based algorithms). Adjacency matrices win for algorithms that repeatedly ask, “Is (i,j) in G?&quot; However, most graph algorithms can be designed to eliminate such queries.</p></li>
</ol>
<p>Will you be modifying the graph over the course of your application? – Efficient static graph implementations can be used when no edge insertion/deletion operations will done following initial construction. Indeed, more common than modifying the topology of the graph is modifying the attributes of a vertex or edge of the graph, such as size, weight, label, or color. Attributes are best handled as extra fields in the vertex or edge records of adjacency lists.</p>
<p><strong>Planar graphs</strong> are those that can be drawn in the plane so no two edges cross. Planar graphs are always sparse, since any n-vertex planar graph can have at most <span class="math inline">\(3n - 6\)</span> edges, thus they should be represented using adjacency lists.</p>
<p><strong>Hypergraphs</strong> are generalized graphs where each edge may link subsets of more than two vertices. In contrast, in an ordinary graph, an edge connects exactly two vertices. Two basic data structures for hypergraphs are: Incidence matrices, which are analogous to adjacency matrices, and Bipartite incidence structures, which are analogous to adjacency lists</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Directed graph </span>
<span class="kw">class</span> Graph(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="va">self</span>.nodes <span class="op">=</span> <span class="bu">set</span>()
        <span class="va">self</span>.edges <span class="op">=</span> defaultdict(<span class="bu">list</span>)
        <span class="va">self</span>.distances <span class="op">=</span> {}

    <span class="kw">def</span> add_node(<span class="va">self</span>, value):
        <span class="va">self</span>.nodes.add(value)

    <span class="kw">def</span> add_edge(<span class="va">self</span>, from_node, to_node, distance):
        <span class="va">self</span>.edges[from_node].append(to_node)
        <span class="va">self</span>.edges[to_node].append(from_node)
        <span class="va">self</span>.distances[(from_node, to_node)] <span class="op">=</span> distance

<span class="co"># Undirected graph using Adjacency Matrix</span>
<span class="kw">class</span> Vertex:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):
        <span class="va">self</span>.name <span class="op">=</span> n

<span class="kw">class</span> Graph:
    vertices <span class="op">=</span> {}
    edges <span class="op">=</span> []
    edge_indices <span class="op">=</span> {}

    <span class="kw">def</span> add_vertex(<span class="va">self</span>, vertex):
        <span class="cf">if</span> <span class="bu">isinstance</span>(vertex, Vertex) <span class="op">and</span> vertex.name <span class="op">not</span> <span class="op">in</span> <span class="va">self</span>.vertices:
            <span class="va">self</span>.vertices[vertex.name] <span class="op">=</span> vertex
            <span class="cf">for</span> row <span class="op">in</span> <span class="va">self</span>.edges:
                row.append(<span class="dv">0</span>)
            <span class="va">self</span>.edges.append([<span class="dv">0</span>] <span class="op">*</span> (<span class="bu">len</span>(<span class="va">self</span>.edges)<span class="op">+</span><span class="dv">1</span>))
            <span class="va">self</span>.edge_indices[vertex.name] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.edge_indices)
            <span class="cf">return</span> <span class="va">True</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">False</span>

    <span class="kw">def</span> add_edge(<span class="va">self</span>, u, v, weight<span class="op">=</span><span class="dv">1</span>):
        <span class="cf">if</span> u <span class="op">in</span> <span class="va">self</span>.vertices <span class="op">and</span> v <span class="op">in</span> <span class="va">self</span>.vertices:
            <span class="va">self</span>.edges[<span class="va">self</span>.edge_indices[u]][<span class="va">self</span>.edge_indices[v]] <span class="op">=</span> weight
            <span class="va">self</span>.edges[<span class="va">self</span>.edge_indices[v]][<span class="va">self</span>.edge_indices[u]] <span class="op">=</span> weight
            <span class="cf">return</span> <span class="va">True</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">False</span>

    <span class="kw">def</span> print_graph(<span class="va">self</span>):
        <span class="cf">for</span> v, i <span class="op">in</span> <span class="bu">sorted</span>(<span class="va">self</span>.edge_indices.items()):
            <span class="bu">print</span>(v <span class="op">+</span> <span class="st">&#39; &#39;</span>, end<span class="op">=</span><span class="st">&#39;&#39;</span>)
            <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(<span class="va">self</span>.edges)):
                <span class="bu">print</span>(<span class="va">self</span>.edges[i][j], end<span class="op">=</span><span class="st">&#39;&#39;</span>)
            <span class="bu">print</span>(<span class="st">&#39; &#39;</span>)

<span class="co"># Undirected graph using Adjacency Lists</span>
<span class="kw">class</span> Vertex:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):
        <span class="va">self</span>.name <span class="op">=</span> n
        <span class="va">self</span>.neighbors <span class="op">=</span> <span class="bu">list</span>()

    <span class="kw">def</span> add_neighbor(<span class="va">self</span>, v):
        <span class="cf">if</span> v <span class="op">not</span> <span class="op">in</span> <span class="va">self</span>.neighbors:
            <span class="va">self</span>.neighbors.append(v)
            <span class="va">self</span>.neighbors.sort()

<span class="kw">class</span> Graph:
    vertices <span class="op">=</span> {}

    <span class="kw">def</span> add_vertex(<span class="va">self</span>, vertex):
        <span class="cf">if</span> <span class="bu">isinstance</span>(vertex, Vertex) <span class="op">and</span> vertex.name <span class="op">not</span> <span class="op">in</span> <span class="va">self</span>.vertices:
            <span class="va">self</span>.vertices[vertex.name] <span class="op">=</span> vertex
            <span class="cf">return</span> <span class="va">True</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">False</span>

    <span class="kw">def</span> add_edge(<span class="va">self</span>, u, v):
        <span class="cf">if</span> u <span class="op">in</span> <span class="va">self</span>.vertices <span class="op">and</span> v <span class="op">in</span> <span class="va">self</span>.vertices:
            <span class="va">self</span>.vertices[u].add_neighbor(v)
            <span class="va">self</span>.vertices[v].add_neighbor(u)
            <span class="cf">return</span> <span class="va">True</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">False</span>

    <span class="kw">def</span> print_graph(<span class="va">self</span>):
        <span class="cf">for</span> key <span class="op">in</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="va">self</span>.vertices.keys())):
            <span class="bu">print</span>(key <span class="op">+</span> <span class="bu">str</span>(<span class="va">self</span>.vertices[key].neighbors))</code></pre></div>
<h2 id="hash-tables">Hash Tables</h2>
<p>A hash table is a data structure that maps keys to values for highly efficient lookup. There are a number of ways of implementing this. First, we will describe a simple but common implementation known as <strong>separate chaining</strong>. In this implementation, we use an array of linked lists and a hash code function. To insert a key (which might be a string or essentially any other data type) and value, we do the following:</p>
<ol style="list-style-type: decimal">
<li><p>First, compute the key’s hash code, which will usually be an <em>int</em> or <em>long</em>. Note that two different keys could have the same hash code, as there may be an infinite number of keys and a finite number of ints.</p></li>
<li><p>Then, map the hash code to an index in the array. This could be done with something like <span class="math inline">\(hash(key)\mod array\_length\)</span>. Two different hash codes could map to the same index.</p></li>
<li><p>At this index, there is a linked list of keys and values. Store the key and value in this index. We must use a linked list because of collisions: you could have two different keys with the same hash code, or two different hash codes that map to the same index.</p></li>
</ol>
<p>To retrieve the value pair by its key, you repeat this process. Compute the hash code from the key, and then compute the index from the hash code. Then, search through the linked list for the value with this key. If the number of collisions is very high, the worst case runtime is <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>, where <span class="math inline">\(n\)</span> is the number of keys. However, we generally assume a good implementation that keeps collisions to a minimum, in which case the lookup time is <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span>. Alternatively, we can implement the hash table with a balanced binary search tree. This gives us an <span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span> lookup time. The advantage of this is potentially using less space, since we no longer allocate a large array. We can also iterate through the keys in order, which can be useful sometimes.</p>
<p>The other strategy used to resolve collisions is to require each array element to contain only one key, but to allow keys to be mapped to alternate indices when their original spot is already occupied. This is known as <strong>open addressing</strong>. In this type of hashing, we have a parameterized hash function <span class="math inline">\(h\)</span> that takes two arguments, a key and a positive integer. Searching for an item requires examining not just one spot, but many spots until either we find the key, or reach a None value. After we delete an item, we replace it with a special value Deleted, rather than simply None. This way, the Search algorithm will not halt when it reaches an index that belonged to a deleted key.</p>
<p>The simplest implementation of open addressing is <strong>linear probing</strong>: start at a given hash value and then keep adding some fixed offset to the index until an empty spot is found. The main problem with linear probing is that the hash values in the middle of a cluster will follow the exact same search pattern as a hash value at the beginning of the cluster. As such, more and more keys are absorbed into this long search pattern as clusters grow. We can solve this problem using <strong>quadratic probing</strong>, which causes the offset between consecutive indices in the probe sequence to increase as the probe sequence is visited. <strong>Double hashing</strong> resolves the problem of a form of clustering occurs where if many items have the same initial hash value, they still follow the exact same probe sequence. It does this by using a hash function for both the initial value and its offset.</p>
<p>A useful hash function for strings is, <span class="math display">\[H(S,j) = \sum_{i=0}^{m-1} \alpha^{m-(i+1)} \cdot char(s_{i+j}) \mod m\]</span> where <span class="math inline">\(\alpha\)</span> is the size of the alphabet and <span class="math inline">\(char(x)\)</span> is the ASCII character code. This hash function has the useful property allowing hashes of successive m-character windows of a string to be computed in constant time instead of <span class="math inline">\({\ensuremath{\mathcal{O}}}(m)\)</span>. <span class="math display">\[H(S, j+1) = (H(S,j) - \alpha^{m-1}char(s_j))\alpha + s_{j+m}\]</span></p>
<h3 id="dictionaries">Dictionaries</h3>
<p>The dictionary data type permits access to data items based on its content. You insert an item into a dictionary so you can retrieve it when you need it. The primary operations a dictionary supports are:</p>
<ul>
<li><p><strong>search(D, k)</strong> – Given a search key <span class="math inline">\(k\)</span>, return a pointer to the element in dictionary <span class="math inline">\(D\)</span> whose key value is <span class="math inline">\(k\)</span>, if one exists.</p></li>
<li><p><strong>insert(D, x)</strong> – Given a data item <span class="math inline">\(x\)</span>, add it to the set in the dictionary <span class="math inline">\(D\)</span>.</p></li>
<li><p><strong>delete(D, x)</strong> – Given a pointer to a given data item <span class="math inline">\(x\)</span> in the dictionary <span class="math inline">\(D\)</span>, remove it from <span class="math inline">\(D\)</span>.</p></li>
<li><p><strong>max(D)</strong> or <strong>min(D)</strong> – Retrieve the item with the largest (or smallest) key from <span class="math inline">\(D\)</span>. This enables the dictionary to serve as a priority queue.</p></li>
<li><p><strong>predecessor(D, k)</strong> or <strong>successor(D, k)</strong> – Retrieve the item from <span class="math inline">\(D\)</span> whose key is immediately before (or after) <span class="math inline">\(k\)</span> in sorted order. These enable us to iterate through the elements of the data structure.</p></li>
</ul>
<h3 id="sets">Sets</h3>
<p>In mathematical terms, a set is an unordered collection of unique objects drawn from a fixed universal set. Sorted order turns the problem of finding the union or intersection of two subsets into a linear-time operation, just sweep from left to right and see what you are missing. It makes possible element searching in sublinear time. Finally, printing the elements of a set in a canonical order paradoxically reminds us that order really doesn’t matter.</p>
<p>If each subset contains exactly two elements, they can be thought of as edges in a graph whose vertices represent the universal set. A system of subsets with no restrictions on the cardinality of its members is called a hypergraph.</p>
<ol style="list-style-type: decimal">
<li><p>test whether <span class="math inline">\(u_i \in S_j\)</span></p></li>
<li><p>compute the union or intersection of <span class="math inline">\(S_i\)</span> and <span class="math inline">\(S_j\)</span></p></li>
<li><p>insert or delete members of <span class="math inline">\(S\)</span></p></li>
</ol>
<p>Although sets are commonly implemented with hashtables, other data structures that can be used:</p>
<ol style="list-style-type: decimal">
<li><p>Containers or dictionaries – A subset can also be represented using a linked list, array, or dictionary containing exactly the elements in the subset.</p></li>
<li><p>Bit vectors – An n-bit vector or array can represent any subset <span class="math inline">\(S\)</span> on a universal set <span class="math inline">\(U\)</span> containing <span class="math inline">\(n\)</span> items. Bit <span class="math inline">\(i\)</span> will be 1 if <span class="math inline">\(i \in S\)</span>, and <span class="math inline">\(0\)</span> if not.</p></li>
<li><p>Bloom filters – We can emulate a bit vector in the absence of a fixed universal set by hashing each subset element to an integer from <span class="math inline">\(0\)</span> to <span class="math inline">\(n\)</span> and setting the corresponding bit.</p></li>
</ol>
<h1 id="algorithms-and-techniques">Algorithms and Techniques</h1>
<h2 id="string-and-array-sorting">String and Array Sorting</h2>
<h3 id="binary-search">Binary Search</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span> average and worst case. Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span></p>
<p>In binary search, we look for an element <span class="math inline">\(x\)</span> in a sorted array by first comparing <span class="math inline">\(x\)</span> to the midpoint of the array. If <span class="math inline">\(x\)</span> is less than the midpoint, then we search the left half of the array. If <span class="math inline">\(x\)</span> is greater than the midpoint, then we search the right half of the array. We then repeat this process, treating the left and right halves as subarrays. Again, we compare <span class="math inline">\(x\)</span> to the midpoint of this subarray and then search either its left or right side. We repeat this process until we either find <span class="math inline">\(x\)</span> or the subarray has size 0.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> binary_search(nums, target):
    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span>

    left, right <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span>
    <span class="cf">while</span> left <span class="op">&lt;=</span> right:
        mid <span class="op">=</span> (left <span class="op">+</span> right) <span class="op">//</span> <span class="dv">2</span>
        <span class="cf">if</span> nums[mid] <span class="op">==</span> target:
            <span class="cf">return</span> mid
        <span class="cf">elif</span> nums[mid] <span class="op">&lt;</span> target:
            left <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span>
        <span class="cf">else</span>:
            right <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span>
    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></code></pre></div>
<h3 id="bubble-sort">Bubble Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n^2)\)</span> average and worst case. Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span></p>
<p>In bubble sort, we start at the beginning of the array and swap the first two elements if the first is greater than the second. Then, we go to the next pair, and so on, continuously making sweeps of the array until it is sorted. In doing so, the smaller items slowly “bubble” up to the beginning of the list.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> bubble_sort(A):
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(A) <span class="op">-</span> <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):
        <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(i):
            <span class="cf">if</span> A[j] <span class="op">&gt;</span> A[j <span class="op">+</span> <span class="dv">1</span>]:
                A[j], A[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> A[j <span class="op">+</span> <span class="dv">1</span>], A[j]</code></pre></div>
<h3 id="selection-sort">Selection Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n^2)\)</span> average and worst case. Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span></p>
<p>Selection sort is the child’s algorithm: simple, but inefficient. Find the smallest element using a linear scan and move it to the front (swapping it with the front element). Then, find the second smallest and move it, again doing a linear scan. Continue doing this until all the elements are in place.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> selection_sort(A):
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(A)):
        min_index <span class="op">=</span> i
        <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(A)):
            <span class="cf">if</span> A[j] <span class="op">&lt;</span> A[min_index]:
                min_index <span class="op">=</span> j
        <span class="cf">if</span> i <span class="op">==</span> min_index:
            <span class="cf">continue</span>
        A[i], A[min_index] <span class="op">=</span> A[min_index], A[i]</code></pre></div>
<h3 id="insertion-sort">Insertion Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n^2)\)</span> average and worst case. Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span></p>
<p>Given an array <span class="math inline">\(A\)</span> of size <span class="math inline">\(n\)</span>, iterate <span class="math inline">\(i\)</span> from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> and insert <span class="math inline">\(A[i]\)</span> into a sorted sub array <span class="math inline">\(A[0, i-1]\)</span> until the entire array is sorted. Sorting occurs through pairwise swaps of elements down to their correct positions.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> insertion_sort(A):
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(A)):
        n <span class="op">=</span> A[i]
        pos <span class="op">=</span> i
        <span class="cf">while</span> pos <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">and</span> A[pos<span class="dv">-1</span>] <span class="op">&gt;</span> n:
            A[pos] <span class="op">=</span> A[pos<span class="dv">-1</span>]
            pos <span class="op">-=</span> <span class="dv">1</span>
        A[pos] <span class="op">=</span> n
    <span class="cf">return</span> A</code></pre></div>
<h3 id="merge-sort">Merge Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}( n \log n )\)</span> average and worst case. Space Complexity: Varies on implementation.</p>
<p>Merge sort divides the array in half, sorts each of those halves, and then merges them back together. Each of those halves has the same sorting algorithm applied to it. Eventually, you are merging just two single element arrays. It is the “merge&quot; part that does all the heavy lifting.</p>
<p>The merge method operates by copying all the elements from the target array segment into a helper array, keeping track of where the start of the left and right halves should be. We then iterate through the helper, copying the smaller element from each half into the array. At the end, we copy any remaining elements into the target array. <span class="math display">\[\begin{aligned}
        T(n) &amp;= 
            \underbrace{c_1}_\text{divide}
            + \underbrace{2T(n/2)}_\text{recursion}
            + \underbrace{c  n}_\text{merge}\\
        &amp;= (1 + \log n) \cdot cn\\
        &amp;= {\ensuremath{\mathcal{O}}}(n \log n)
    \end{aligned}\]</span></p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> _merge_lists(left_sublist, right_sublist):
    i, j <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>
    result <span class="op">=</span> []
    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(left_sublist) <span class="op">and</span> j <span class="op">&lt;</span> <span class="bu">len</span>(right_sublist):
        <span class="cf">if</span> left_sublist[i] <span class="op">&lt;=</span> right_sublist[j]:
            result.append(left_sublist[i])
            i <span class="op">+=</span> <span class="dv">1</span>
        <span class="cf">else</span>:
            result.append(right_sublist[j])
            j <span class="op">+=</span> <span class="dv">1</span>
    result <span class="op">+=</span> left_sublist[i:]
    result <span class="op">+=</span> right_sublist[j:]
    <span class="cf">return</span> result

<span class="kw">def</span> merge_sort(A):
    <span class="cf">if</span> <span class="bu">len</span>(A) <span class="op">&lt;=</span> <span class="dv">1</span>:
        <span class="cf">return</span> A
    <span class="cf">else</span>:
        midpoint <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(A)<span class="op">/</span><span class="dv">2</span>)
        left_sublist <span class="op">=</span> merge_sort(A[:midpoint])
        right_sublist <span class="op">=</span> merge_sort(A[midpoint:])
        <span class="cf">return</span> _merge_lists(left_sublist, right_sublist)</code></pre></div>
<h3 id="quicksort">QuickSort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n \log n)\)</span> average, <span class="math inline">\({\ensuremath{\mathcal{O}}}(n^2)\)</span> worst case. Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n )\)</span></p>
<p>In quick sort, we pick an element and partition the array, such that all numbers that are less than the partitioning element come before all elements that are greater than it. The partitioning can be performed efficiently through a series of swaps.</p>
<p>If we repeatedly partition the array (and its sub-arrays) around an element, the array will eventually become sorted. However, as the partitioned element is not guaranteed to be the median (or anywhere near the median), our sorting could be very slow. This is the reason for the 0 (<span class="math inline">\(n^2\)</span>) worst case runtime.</p>
<p>If we allow our algorithm to make random choices, we can turn any input into a “random” input simply by preprocessing it, and then applying the regular quicksort function. To run <strong>randomized quicksort</strong> on an array <span class="math inline">\(A\)</span> with length <span class="math inline">\(n\)</span>, we can define the random variable <span class="math inline">\(T_A\)</span> to be the running time of the algorithm. Now we are considering the probability distribution which the algorithm uses to make its random choices, and not a probability distribution over inputs, <span class="math inline">\(E[T_A] = \Theta(n \log{n})\)</span>.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> random

<span class="kw">def</span> partition(arr, start, end, pivot_mode):
    <span class="cf">if</span> pivot_mode <span class="op">==</span> <span class="st">&#39;first&#39;</span>:
        pivot <span class="op">=</span> arr[start]
    <span class="cf">else</span>:
        pivot_index <span class="op">=</span> random.randrange(start, end)
        pivot <span class="op">=</span> arr[pivot_index]
        arr[pivot_index], arr[start] <span class="op">=</span> arr[start], arr[pivot_index] <span class="co"># place the pivot at the start</span>
    i <span class="op">=</span> start <span class="op">+</span> <span class="dv">1</span>
    <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(start <span class="op">+</span> <span class="dv">1</span>, end <span class="op">+</span> <span class="dv">1</span>):
        <span class="cf">if</span> arr[j] <span class="op">&lt;</span> pivot:
            arr[i], arr[j] <span class="op">=</span> arr[j], arr[i]
            i <span class="op">+=</span> <span class="dv">1</span>
    arr[start], arr[i<span class="dv">-1</span>] <span class="op">=</span> arr[i<span class="dv">-1</span>], arr[start]
    <span class="cf">return</span> i<span class="dv">-1</span>

<span class="kw">def</span> quicksort(arr, start, end, pivot_mode<span class="op">=</span><span class="st">&#39;random&#39;</span>):
    <span class="cf">if</span> start <span class="op">&lt;</span> end:
        split <span class="op">=</span> partition(arr, start, end, pivot_mode)
        quicksort(arr, start, split<span class="dv">-1</span>, pivot_mode)
        quicksort(arr, split<span class="dv">+1</span>, end, pivot_mode)
    <span class="cf">return</span> arr</code></pre></div>
<h3 id="heap-sort">Heap Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n^2)\)</span> average and worst case. Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span></p>
<p>Given a heap, we can extract a sorted list of the elements in the heap simply by repeatedly calling Remove and adding the items to a list. In particular, the Heap Sort algorithm does the following:</p>
<ol style="list-style-type: decimal">
<li><p>Build a max heap from an unordered array A in <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>.</p></li>
<li><p>Find the max element A[1] in <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span>.</p></li>
<li><p>Swap elements A[n] with A[1] so that the max element is at the end of the array in in <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span>.</p></li>
<li><p>Extract node <span class="math inline">\(n\)</span> from the array and decrement the heap size in <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span>.</p></li>
<li><p>The new node may violate the max heap principle but the children won’t. This allows us to run heapify in <span class="math inline">\({\ensuremath{\mathcal{O}}}(\log n)\)</span>.</p></li>
</ol>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> heapq

<span class="kw">def</span> heapsort(A):
    h <span class="op">=</span> []
    <span class="cf">for</span> value <span class="op">in</span> A:
        heapq.heappush(h, value)
    <span class="cf">return</span> [heapq.heappop(h) <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(h))]</code></pre></div>
<h3 id="counting-sort">Counting Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n + k)\)</span> average and worst case, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n + k)\)</span> (where <span class="math inline">\(k\)</span> is the range of the non-negative key values.)</p>
<p>Instead of using comparison operations as in previous sorting algorithms, counting sort uses integer sorting and relies on a sorting technique based on keys between a specific range. It works by counting the number of objects having distinct key values (a kind of hashing), then doing some arithmetic to calculate the position of each object in the output sequence.</p>
<p>Its running time is linear in the number of items and the difference between the maximum and minimum key values, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can handle larger keys more efficiently.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> count_sort(arr):
    output <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">256</span>)]
    count <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">256</span>)]
    ans <span class="op">=</span> [<span class="st">&quot;&quot;</span> <span class="cf">for</span> _ <span class="op">in</span> arr]

    <span class="cf">for</span> i <span class="op">in</span> arr:
        count[<span class="bu">ord</span>(i)] <span class="op">+=</span> <span class="dv">1</span>

    <span class="co"># Change count[i] so that count[i] now contains actual</span>
    <span class="co"># position of this character in output array</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">256</span>):
        count[i] <span class="op">+=</span> count[i<span class="dv">-1</span>]

    <span class="co"># Build the output character array</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(arr)):
        output[count[<span class="bu">ord</span>(arr[i])]<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> arr[i]
        count[<span class="bu">ord</span>(arr[i])] <span class="op">-=</span> <span class="dv">1</span>

    <span class="co"># Copy the output array to arr, so that arr now</span>
    <span class="co"># contains sorted characters</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(arr)):
        ans[i] <span class="op">=</span> output[i]
    <span class="cf">return</span> ans</code></pre></div>
<h3 id="radix-sort">Radix Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(w \cdot n)\)</span> average and worst case, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(w + n)\)</span> (where <span class="math inline">\(w\)</span> is the number of bits required to store each key)</p>
<p>Radix is a Latin word for “root&quot; which can be considered a synonym for an arithmetical base, where decimal is base 10. For simplicity, say you want to use the decimal radix (= 10) for sorting. Then you would start by separating the numbers by units and then putting them together again; next you would separate the numbers by tens and then put them together again; then by hundreds and so on until all the numbers are sorted. Each time you loop, just read the list from left to right. You can also imagine you are separating the numbers into buckets.</p>
<p>Radix sort can be applied to data that can be sorted lexicographically, i.e integers, words, playing cards, etc. Unlike radix sort, quicksort is universal, while radix sort is only useful for fixed length integer keys. It’s also of note that <span class="math inline">\({\ensuremath{\mathcal{O}}}(f(n))\)</span> really means in order of <span class="math inline">\(K*f(n)\)</span>, where <span class="math inline">\(K\)</span> is some arbitrary constant. For radix sort this <span class="math inline">\(K\)</span> happens to be quite large (at least on the order of number of bits in the integers sorted), on the other hand quicksort has one of the lowest <span class="math inline">\(K\)</span> among all sorting algorithms and average complexity of <span class="math inline">\(n \cdot \log(n)\)</span>. Thus in real life scenario quicksort will often be faster than radix sort.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> radix_sort(A):
    RADIX <span class="op">=</span> <span class="dv">10</span>
    maxLength <span class="op">=</span> <span class="va">False</span>
    tmp, placement <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>

    <span class="cf">while</span> <span class="op">not</span> maxLength:
        maxLength <span class="op">=</span> <span class="va">True</span>
        <span class="co"># declare and initialize buckets</span>
        buckets <span class="op">=</span> [<span class="bu">list</span>() <span class="cf">for</span> _ <span class="op">in</span> <span class="bu">range</span>(RADIX)]

        <span class="co"># split A between lists</span>
        <span class="cf">for</span> i <span class="op">in</span> A:
            tmp <span class="op">=</span> i <span class="op">/</span> placement
            buckets[tmp <span class="op">%</span> RADIX].append(i)
            <span class="cf">if</span> maxLength <span class="op">and</span> tmp <span class="op">&gt;</span> <span class="dv">0</span>:
                maxLength <span class="op">=</span> <span class="va">False</span>

        <span class="co"># empty lists into A array</span>
        a <span class="op">=</span> <span class="dv">0</span>
        <span class="cf">for</span> b <span class="op">in</span> <span class="bu">range</span>(RADIX):
            buck <span class="op">=</span> buckets[b]
            <span class="cf">for</span> i <span class="op">in</span> buck:
                A[a] <span class="op">=</span> i
                a <span class="op">+=</span> <span class="dv">1</span>

        <span class="co"># move to next digit</span>
        placement <span class="op">*=</span> RADIX</code></pre></div>
<h3 id="timsort">Timsort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span> Best-case, <span class="math inline">\({\ensuremath{\mathcal{O}}}(n\log n)\)</span> average and worst case, Memory <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>.</p>
<p>Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. The algorithm finds subsequences of the data that are already ordered (runs) and uses them to sort the remainder more efficiently. This is done by merging runs until certain criteria are fulfilled. Timsort has been Python’s standard sorting algorithm since version 2.3.</p>
<h2 id="array-analysis-methods">Array Analysis Methods</h2>
<h3 id="two-pointer-technique">Two Pointer Technique</h3>
<p>Time complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n^2)\)</span>, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span></p>
<p>The two pointer technique uses two references to values in a given array to check if they satisfy a condition otherwise the pointers (usually) move towards the middle of the array being iterated over.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> left_right_boundary(<span class="va">self</span>, seq):
    left, right <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(seq) <span class="op">-</span> <span class="dv">1</span>
    <span class="cf">while</span> left <span class="op">&lt;</span> right:
        <span class="cf">if</span> <span class="va">self</span>.left_condition(left):
            left <span class="op">+=</span> <span class="dv">1</span>

        <span class="cf">if</span> <span class="va">self</span>.right_condition(right):
            right <span class="op">-=</span> <span class="dv">1</span>

        <span class="va">self</span>.validate(left, right)</code></pre></div>
<h3 id="fast-and-slow-pointers">Fast and Slow Pointers</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span></p>
<p>The fast and slow pointers/runners pattern (a.k.a. Floyd’s Tortoise and Hare Algorithm) is very useful when dealing with cyclic linked lists or arrays. By moving at different speeds, the algorithm proves that the two pointers are going to meet eventually. The fast pointer should catch the slow pointer once both the pointers are in a cyclic loop.</p>
<p>If the list has <span class="math inline">\(n\)</span> nodes, then in <span class="math inline">\(\leq n\)</span> steps, either the fast pointer will find the end of the list, or there is a loop and the slow pointer will be in the loop.</p>
<p>Lets say the loop is of length <span class="math inline">\(m \leq n\)</span>: Once the slow pointer is in the loop, both the fast and slow pointers will be stuck in the loop forever. Each step, the distance between the fast and the slow pointers will increase by 1. When the distance is divisible by <span class="math inline">\(m\)</span>, then the fast and slow pointers will be on the same node and the algorithm terminates. The distance will reach a number divisible by <span class="math inline">\(m\)</span> in <span class="math inline">\(\leq m\)</span> steps.</p>
<p>So, getting the slow pointer to the loop, and then getting the fast and slow pointers to meet takes <span class="math inline">\(\leq n + m \leq 2n\)</span> steps, and that is in <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> has_cycle(<span class="va">self</span>, head):
    <span class="cf">try</span>:
        slow, fast <span class="op">=</span> head, head.<span class="bu">next</span>
        <span class="cf">while</span> slow <span class="op">is</span> <span class="op">not</span> fast:
            slow <span class="op">=</span> slow.<span class="bu">next</span>
            fast <span class="op">=</span> fast.<span class="bu">next</span>.<span class="bu">next</span>
        <span class="cf">return</span> <span class="va">True</span>
    <span class="cf">except</span> <span class="pp">AttributeError</span>:
        <span class="cf">return</span> <span class="va">False</span></code></pre></div>
<h3 id="sliding-window-technique">Sliding Window Technique</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(k)\)</span>, where <span class="math inline">\(k\)</span> is the length of a pattern or restrict sequence</p>
<ol style="list-style-type: decimal">
<li><p>Use two pointers, start and end, to represent a window.</p></li>
<li><p>Move end to find a valid window.</p></li>
<li><p>When a valid window is found, move start to find a smaller window.</p></li>
</ol>
<p>Sliding windows are commonly used to find a match or maximum/minimum in a given subarray or substring. It uses two pointers as the boundary of a sliding window to traverse and may also use a counter dictionary to maintain current state.</p>
<p>The characteristics of problems that can be solved using the two pointer technique:</p>
<ol style="list-style-type: decimal">
<li><p>If the narrow scope of your window is valid, then the wider scope is valid. By definition of the narrow window being a sub problem of the wider problem.</p></li>
<li><p>If the wider scope of the window is invalid, then the narrow scope is also invalid. By definition of the wider window being a full problem of the given sub problem.</p></li>
<li><p>If the narrow scope of your window is invalid, it doesn’t always mean the wider scope is invalid. You need to increment the pointers to find out (this is why the 2 pointer solution works, after all). In a given narrow window, you cannot guarantee that this window means the solution cannot be found, because the narrow window is just a slice of a given string or subarray. Then, if all sub-problems are solved and the wider problem is also invalid, then we can say that all sub problems or sub strings cannot be formed to solve the problem.</p></li>
</ol>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> basic_sliding_window(<span class="va">self</span>, seq):
    start, end <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>
    <span class="cf">while</span> end <span class="op">&lt;</span> <span class="bu">len</span>(seq):
        <span class="co"># end grows in the outer loop</span>
        end <span class="op">+=</span> <span class="dv">1</span>
        <span class="co"># start grows with some restrict</span>
        <span class="cf">while</span> <span class="va">self</span>.start_condition(start):
            <span class="co"># process logic before pointers movement</span>
            <span class="va">self</span>.process_logic1(start, end)
            <span class="co"># start grows in the inner loop</span>
            start <span class="op">+=</span> <span class="dv">1</span>
        <span class="co"># or process logic after pointers movement</span>
        <span class="va">self</span>.process_logic2(start, end)

<span class="co"># Using a counter</span>
<span class="im">from</span> collections <span class="im">import</span> Counter

<span class="co"># s - target sequence, p - pattern or restrict sequence</span>
<span class="kw">def</span> sliding_window_with_counter(s, p):
    counter <span class="op">=</span> Counter(p)
    start, end, count, res <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>
    <span class="cf">while</span> end <span class="op">&lt;</span> <span class="bu">len</span>(s):
        counter[s[end]] <span class="op">+=</span> <span class="dv">1</span>
        <span class="cf">if</span> counter[s[end]] <span class="op">&gt;</span> <span class="dv">1</span>:
            count <span class="op">+=</span> <span class="dv">1</span>
        end <span class="op">+=</span> <span class="dv">1</span>
        <span class="cf">while</span> count <span class="op">&gt;</span> <span class="dv">0</span>:
            <span class="co"># update res here if finding minimum</span>
            <span class="co"># increase start to make it invalid or valid again</span>
            counter[s[start]] <span class="op">-=</span> <span class="dv">1</span>
            <span class="co"># update count based on some condition</span>
            <span class="cf">if</span> counter[s[start]] <span class="op">&gt;</span> <span class="dv">0</span>:
                count <span class="op">-=</span> <span class="dv">1</span>
            start <span class="op">+=</span> <span class="dv">1</span>
        <span class="co"># update res here if finding maximum</span>
        res <span class="op">=</span> <span class="bu">max</span>(res, end <span class="op">-</span> start)
    <span class="cf">return</span> res</code></pre></div>
<h3 id="single-pass-with-lookup-table">Single-pass with Lookup Table</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span></p>
<p>This technique is useful when searching an array for a pair of values, though the method can be extrapolated to triples and more. Given an array and a target we first initialize a lookup table, usually as a hash table or dictionary. Next, we iterate over the array checking if the complement to the current value needed to satisfy the target exists in our lookup table. If it exists, meaning we’ve visited the complement before, we retrieve the value from the pointer in the lookup and return it with the current index. Otherwise we add the current value to the lookup table with its index.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> single_pass_lookup(nums], target):
    lookup <span class="op">=</span> {}
    <span class="cf">for</span> i, v <span class="op">in</span> <span class="bu">enumerate</span>(nums):
        <span class="cf">if</span> target <span class="op">-</span> v <span class="op">in</span> lookup:
            <span class="cf">return</span> i, lookup[target <span class="op">-</span> v]
        lookup[v] <span class="op">=</span> i
    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;Target not in list.&#39;</span>)</code></pre></div>
<h3 id="range-operations-on-array">Range Operations on Array</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(Q + n)\)</span>, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span>, where <span class="math inline">\(Q\)</span> is the number of operations/queries</p>
<p>Given an array <span class="math inline">\(A\)</span> of 0’s of size <span class="math inline">\(n\)</span>, perform <span class="math inline">\(Q\)</span> operations or queries by incrementing values in the subarray <span class="math inline">\(A[L: R]\)</span> by 1. A naive brute force solution of performing all the given operations will result in time complexity of <span class="math inline">\({\ensuremath{\mathcal{O}}}(Q\cdot n)\)</span>.</p>
<p>However, using a numerical method we are able to reduce the time complexity to <span class="math inline">\({\ensuremath{\mathcal{O}}}(Q + n)\)</span>. This technique involves creating a secondary array <span class="math inline">\(B\)</span> and only incrementing the value at the left endpoint, <span class="math inline">\(L\)</span> by 1 and decrementing the value at index <span class="math inline">\(R + 1\)</span> by 1. After repeating this process for all queries, to find the true desired value of <span class="math inline">\(A[i]\)</span> we can find the prefix sum of <span class="math inline">\(B\)</span> from <span class="math inline">\(B[0:i]\)</span>.</p>
<p>If instead we want to find the maximum in the array after performing <span class="math inline">\(Q\)</span> range operations, we can modify the above techinque which will give us an algorithm that runs in <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>. It does this by storing the difference between the current element and the previous element. This means that we add the sum to <span class="math inline">\(A[i]\)</span> showing that <span class="math inline">\(A[i]\)</span> is greater than its previous element by the sum. We subtract sum from <span class="math inline">\(A[j+1]\)</span> to show that <span class="math inline">\(A[j+1]\)</span> is less than <span class="math inline">\(A[j]\)</span> by sum (since <span class="math inline">\(A[j]\)</span> was the last element that was added to sum). By the end of all this, we have an array that shows the difference between every successive element. By adding all the positive differences, we get the value of the maximum element</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> arrayOperations(n, operations):
    B <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">for</span> start, end, incr <span class="op">in</span> operations:
        B[start <span class="op">-</span> <span class="dv">1</span>] <span class="op">+=</span> incr
        <span class="cf">if</span> stop <span class="op">&lt;=</span> <span class="bu">len</span>(B):
            B[stop] <span class="op">-=</span> incr<span class="op">;</span>
    <span class="bu">max</span> <span class="op">=</span> cur <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> i <span class="op">in</span> B:
        cur <span class="op">=</span> cur <span class="op">+</span> i<span class="op">;</span>
        <span class="cf">if</span> <span class="bu">max</span> <span class="op">&lt;</span> cur: 
            <span class="bu">max</span> <span class="op">=</span> cur<span class="op">;</span>
    <span class="cf">return</span> <span class="bu">max</span></code></pre></div>
<h3 id="kadanes-algorithm">Kadane’s Algorithm</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(1)\)</span></p>
<p>The maximum sum subarray problem is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional array <span class="math inline">\(A[1...n]\)</span> of numbers.</p>
<p>This problem can be solved using several different algorithmic techniques, including brute force, divide and conquer, dynamic programming, and reduction to shortest paths. Kadane’s algorithm can be viewed as a trivial example of dynamic programming which will be visited in more detail later.</p>
<ol style="list-style-type: decimal">
<li><p>Use the input vector nums to store the candidate subarrays sum (i.e. the greatest contiguous sum so far).</p></li>
<li><p>Ignore cumulative negatives, as they don’t contribute positively to the sum.</p></li>
</ol>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> maxSubArray(<span class="va">self</span>, nums: List[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):
        <span class="cf">if</span> nums[i<span class="dv">-1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:
            nums[i] <span class="op">+=</span> nums[i<span class="dv">-1</span>]
    <span class="cf">return</span> <span class="bu">max</span>(nums)</code></pre></div>
<h2 id="string-analysis-methods">String Analysis Methods</h2>
<p>A string is a sequence of ASCII characters. Many analysis techniques that apply to arrays can also be used on string inputs when they are interpreted as character arrays.</p>
<h3 id="kmp-pattern-matching">KMP Pattern Matching</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span> Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(k)\)</span>, where <span class="math inline">\(n\)</span> is the length of the string and <span class="math inline">\(k\)</span> is the length of the pattern</p>
<p>KMP (Knuth Morris Pratt) pattern matching improves the worst case complexity of a naive approach to <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span>. The basic idea behind KMP’s algorithm is that whenever we detect a mismatch after some matches, we know some of the characters in the text of the next window. Instead of wasting computation on previous matches, we use a precomputed lookup table to skip to the first instance of a match of the starting character.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> KMP:
    <span class="kw">def</span> partial(<span class="va">self</span>, pattern):
        <span class="co">&quot;&quot;&quot; Calculate partial match table: String -&gt; [Int]&quot;&quot;&quot;</span>
        ret <span class="op">=</span> [<span class="dv">0</span>]
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(pattern)):
            j <span class="op">=</span> ret[i <span class="op">-</span> <span class="dv">1</span>]
            <span class="cf">while</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">and</span> pattern[j] <span class="op">!=</span> pattern[i]:
                j <span class="op">=</span> ret[j <span class="op">-</span> <span class="dv">1</span>]
            ret.append(j <span class="op">+</span> <span class="dv">1</span> <span class="cf">if</span> pattern[j] <span class="op">==</span> pattern[i] <span class="cf">else</span> j)
        <span class="cf">return</span> ret
        
    <span class="kw">def</span> search(<span class="va">self</span>, T, P):
        <span class="co">&quot;&quot;&quot; </span>
<span class="co">        KMP search main algorithm: String -&gt; String -&gt; [Int] </span>
<span class="co">        Return all the matching position of pattern string P in T</span>
<span class="co">        &quot;&quot;&quot;</span>
        partial, ret, j <span class="op">=</span> <span class="va">self</span>.partial(P), [], <span class="dv">0</span>
        
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(T)):
            <span class="cf">while</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">and</span> T[i] <span class="op">!=</span> P[j]:
                j <span class="op">=</span> partial[j <span class="op">-</span> <span class="dv">1</span>]
            <span class="cf">if</span> T[i] <span class="op">==</span> P[j]: j <span class="op">+=</span> <span class="dv">1</span>
            <span class="cf">if</span> j <span class="op">==</span> <span class="bu">len</span>(P): 
                ret.append(i <span class="op">-</span> (j <span class="op">-</span> <span class="dv">1</span>))
                j <span class="op">=</span> partial[j <span class="op">-</span> <span class="dv">1</span>]
            
        <span class="cf">return</span> ret</code></pre></div>
<h3 id="rabinkarp">Rabin–Karp</h3>
<p>The Rabin–Karp algorithm is a string-searching algorithm that uses hashing to find an exact match of a pattern string in a text. It uses a rolling hash to quickly filter out positions of the text that cannot match the pattern, and then checks for a match at the remaining positions.</p>
<h3 id="merge-intervals">Merge Intervals</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n \log n)\)</span>, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(n)\)</span></p>
<p>An interval problem has an input of a 2d array in which each nested array represents a start and an end value. The interval can also be represented as an object with start and end attributes.</p>
<p>Given two intervals A and B, there will be six different ways the two intervals can relate to each other:</p>
<ol style="list-style-type: decimal">
<li><p>A and B do not overlap, A before B</p></li>
<li><p>A and B overlap, B ends after A</p></li>
<li><p>A completely overlaps B</p></li>
<li><p>A and B overlap, A ends after B</p></li>
<li><p>A and B do not overlap, B before A</p></li>
</ol>
<p>If a.start <span class="math inline">\(\leq\)</span> b.start, only 1, 2 and 3 are possible from the above scenarios. Our goal is to merge the intervals whenever they overlap.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> merge_intervals(<span class="va">self</span>, intervals):
    <span class="cf">if</span> <span class="bu">len</span>(intervals) <span class="op">&lt;</span> <span class="dv">2</span>: <span class="cf">return</span> intervals

    intervals.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>])
    merged <span class="op">=</span> []
    start <span class="op">=</span> intervals[<span class="dv">0</span>][<span class="dv">0</span>]
    end <span class="op">=</span> intervals[<span class="dv">0</span>][<span class="dv">1</span>]

    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(intervals)):
        interval <span class="op">=</span> intervals[i]
        <span class="cf">if</span> interval[<span class="dv">0</span>] <span class="op">&lt;=</span> end:  <span class="co"># overlapping intervals</span>
            end <span class="op">=</span> <span class="bu">max</span>(interval[<span class="dv">1</span>], end)
        <span class="cf">else</span>:  <span class="co"># non-overlapping interval, add the previous interval and reset</span>
            merged.append([start, end])
            start <span class="op">=</span> interval[<span class="dv">0</span>]
            end <span class="op">=</span> interval[<span class="dv">1</span>]

    merged.append([start, end])  <span class="co"># add the last interval</span>
    <span class="cf">return</span> merged</code></pre></div>
<h2 id="tree-traversal">Tree Traversal</h2>
<p>Given a binary tree, an <strong>in-order traversal</strong> (LNR) means to visit the left branch, then the current node, and finally, the right branch. A <strong>pre-order traversal</strong> (NLR) visits the current node before its child nodes, i.e. the root is always the first node visited. A <strong>post-order traversal</strong> (LRN) visits the current node after its child nodes, i.e. the root node is always the last node visited.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> inorder(root): 
    <span class="cf">if</span> root: 
        inorder(root.left) 
        <span class="bu">print</span>(root.val)
        inorder(root.right) 
  
<span class="kw">def</span> postorder(root): 
    <span class="cf">if</span> root: 
        postorder(root.left) 
        postorder(root.right) 
        <span class="bu">print</span>(root.val)
        
<span class="kw">def</span> preorder(root): 
    <span class="cf">if</span> root: 
        <span class="bu">print</span>(root.val)
        preorder(root.left) 
        preorder(root.right) </code></pre></div>
<h2 id="heap-use-cases">Heap Use Cases</h2>
<h3 id="top-k-numbers">Top K Numbers</h3>
<p>The best data structure to keep track of top <span class="math inline">\(K\)</span> elements is a heap. If we iterate through an array, one element at a time, and keep <span class="math inline">\(K\)</span>-th largest element in a heap such that each time we find a larger number than the smallest number in the heap, we do two things:</p>
<ol style="list-style-type: decimal">
<li><p>Take out the smallest number from the heap</p></li>
<li><p>Insert the larger number into the heap</p></li>
</ol>
<p>This will ensure that we always have top <span class="math inline">\(K\)</span> largest numbers in the heap. We may use a min-heap for this.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> heapq

<span class="co"># For maintaining a class</span>
<span class="kw">class</span> KthLargestHeap:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, k: <span class="bu">int</span>, nums):
        <span class="va">self</span>.pq, <span class="va">self</span>.k <span class="op">=</span> [], k
        <span class="cf">for</span> n <span class="op">in</span> nums:
            <span class="va">self</span>.add(n)

    <span class="kw">def</span> add(<span class="va">self</span>, val: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:
        heapq.heappush(<span class="va">self</span>.pq, val)
        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.pq) <span class="op">&gt;</span> <span class="va">self</span>.k:
            heapq.heappop(<span class="va">self</span>.pq)
        <span class="cf">return</span> <span class="va">self</span>.pq[<span class="dv">0</span>]

<span class="co"># For one time calculation</span>
<span class="kw">def</span> findKthLargest(<span class="va">self</span>, nums: List[<span class="bu">int</span>], k: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:
        min_heap <span class="op">=</span> []
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(k):
            heapq.heappush(min_heap, nums[i])
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(k, <span class="bu">len</span>(nums)):
            <span class="cf">if</span> nums[i] <span class="op">&gt;</span> min_heap[<span class="dv">0</span>]:
                heapq.heappop(min_heap)
                heapq.heappush(min_heap, nums[i])
        <span class="cf">return</span> min_heap[<span class="dv">0</span>]</code></pre></div>
<h3 id="two-heaps-median-of-data-stream">Two Heaps (Median of Data Stream)</h3>
<p>If we maintain two heaps, we can keep track of the bigger half and the smaller half of a stream of data. The bigger half is kept in a min heap, such that the smallest element in the bigger half is at the root. The smaller half is kept in a max heap, such that the biggest element of the smaller half is at the root. Now, with these data structures, we have the potential median elements at the roots. If the heaps are no longer the same size, we can easily re-balance the heaps by popping an element off the one heap and pushing it onto the other.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> heapq <span class="im">import</span> <span class="op">*</span>

<span class="kw">class</span> MedianFinder:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="va">self</span>.heaps <span class="op">=</span> [], []

    <span class="kw">def</span> addNum(<span class="va">self</span>, num):
        small, large <span class="op">=</span> <span class="va">self</span>.heaps
        <span class="co">#convert a min heap to a max heap. heapq only has a min heap by default.</span>
        heappush(small, <span class="op">-</span>heappushpop(large, num))
        <span class="cf">if</span> <span class="bu">len</span>(large) <span class="op">&lt;</span> <span class="bu">len</span>(small):
            heappush(large, <span class="op">-</span>heappop(small))

    <span class="kw">def</span> findMedian(<span class="va">self</span>):
        small, large <span class="op">=</span> <span class="va">self</span>.heaps
        <span class="cf">if</span> <span class="bu">len</span>(large) <span class="op">&gt;</span> <span class="bu">len</span>(small):
            <span class="cf">return</span> <span class="bu">float</span>(large[<span class="dv">0</span>])
        <span class="cf">return</span> (large[<span class="dv">0</span>] <span class="op">-</span> small[<span class="dv">0</span>]) <span class="op">/</span> <span class="fl">2.0</span></code></pre></div>
<h2 id="graph-traversal">Graph Traversal</h2>
<h3 id="breadth-first-search">Breadth-First Search</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(|V| + |E|)\)</span> worst case, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(|V|)\)</span></p>
<p>In a breadth-first search (BFS), we start at the root (or another arbitrarily selected node) and explore each neighbor before going on to any of their children. That is, we go wide before we go deep.</p>
<p>In BFS, node x visits each of x’s neighbors before visiting any of their neighbors. You can think of this as searching level by level out from x. An iterative solution involving a <strong>queue</strong> usually works best.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> collections <span class="im">import</span> deque

<span class="kw">def</span> bfs(matrix):
    <span class="co"># Check for an empty graph.</span>
    <span class="cf">if</span> <span class="op">not</span> matrix:
        <span class="cf">return</span> []

    rows, cols <span class="op">=</span> <span class="bu">len</span>(matrix), <span class="bu">len</span>(matrix[<span class="dv">0</span>])
    visited <span class="op">=</span> <span class="bu">set</span>()
    directions <span class="op">=</span> ((<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">0</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>))

    <span class="kw">def</span> traverse(i, j):
        queue <span class="op">=</span> deque([(i, j)])
        <span class="cf">while</span> queue:
            curr_i, curr_j <span class="op">=</span> queue.popleft()
            <span class="cf">if</span> (curr_i, curr_j) <span class="op">not</span> <span class="op">in</span> visited:
                visited.add((curr_i, curr_j))
                <span class="co"># Traverse neighbors.</span>
                <span class="cf">for</span> direction <span class="op">in</span> directions:
                    next_i, next_j <span class="op">=</span> curr_i <span class="op">+</span> <span class="op">\</span>
                        direction[<span class="dv">0</span>], curr_j <span class="op">+</span> direction[<span class="dv">1</span>]
                    <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> next_i <span class="op">&lt;</span> rows <span class="op">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> next_j <span class="op">&lt;</span> cols:
                        <span class="co"># Add in your question-specific checks.</span>
                        queue.append((next_i, next_j))

    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(rows):
        <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(cols):
            traverse(i, j)</code></pre></div>
<h3 id="depth-first-search">Depth-First Search</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(|V| + |E|)\)</span> worst case, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(|V|)\)</span></p>
<p>In depth-first search (DFS), we start at the root (or another arbitrarily selected node) and explore each branch completely before moving on to the next branch. That is, we go deep first before we go wide.</p>
<p>Note that pre-order and other forms of tree traversal are a form of DFS. The key difference is that when implementing this algorithm for a graph, we must check if the node has been visited. If we don’t, we risk getting stuck in an infinite loop.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> dfs(matrix):
    <span class="co"># Check for an empty graph.</span>
    <span class="cf">if</span> <span class="op">not</span> matrix:
        <span class="cf">return</span> []

    rows, cols <span class="op">=</span> <span class="bu">len</span>(matrix), <span class="bu">len</span>(matrix[<span class="dv">0</span>])
    visited <span class="op">=</span> <span class="bu">set</span>()
    directions <span class="op">=</span> ((<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">0</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>))

    <span class="kw">def</span> traverse(i, j):
        <span class="cf">if</span> (i, j) <span class="op">in</span> visited:
            <span class="cf">return</span>

        visited.add((i, j))
        <span class="co"># Traverse neighbors.</span>
        <span class="cf">for</span> direction <span class="op">in</span> directions:
            next_i, next_j <span class="op">=</span> i <span class="op">+</span> direction[<span class="dv">0</span>], j <span class="op">+</span> direction[<span class="dv">1</span>]
            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> next_i <span class="op">&lt;</span> rows <span class="op">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> next_j <span class="op">&lt;</span> cols:
                <span class="co"># Add in your question-specific checks.</span>
                traverse(next_i, next_j)

    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(rows):
        <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(cols):
            traverse(i, j)</code></pre></div>
<h3 id="bidirectional-search">Bidirectional Search</h3>
<p>Bidirectional search is used to find the shortest path between a source and destination node. It operates by essentially running two simultaneous breadth-first searches, one from each node. When their searches collide, we have found a path. If every node has at most <span class="math inline">\(k\)</span> adjacent nodes and the shortest path from node <span class="math inline">\(s\)</span> to node <span class="math inline">\(t\)</span> has length. Then, in a traditional breadth-first search we visit <span class="math inline">\(\mathcal{O}(k^d)\)</span> nodes while bidrectional search visits <span class="math inline">\(\mathcal{O}(k^{d/2})\)</span></p>
<h3 id="dijkstras-algorithm">Dijkstra’s algorithm</h3>
<p>Time Complexity: <span class="math inline">\(\Theta (|E|+|V|\log |V|)\)</span> worst case</p>
<p>An algorithm for finding the shortest paths between nodes in a graph. For a given source node in the graph, the algorithm finds the shortest path between that node and every other. Let the node at which we are starting be called the initial node and the distance of node Y be the distance from the initial node to Y. Dijkstra’s algorithm will assign some initial distance values and will try to improve them step by step.</p>
<p>Djikstra’s algorithm prioritizes shorter distances and edges with low weights in its path discovery process.</p>
<ol style="list-style-type: decimal">
<li><p>Mark all nodes unvisited. Create a set of all the unvisited nodes called the unvisited set.</p></li>
<li><p>Assign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes. Set the initial node as current.</p></li>
<li><p>For the current node, consider all of its unvisited neighbours and calculate their tentative distances through the current node. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one. For example, if the current node A is marked with a distance of 6, and the edge connecting it with a neighbour B has length 2, then the distance to B through A will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, the current value will be kept.</p></li>
<li><p>When we are done considering all of the unvisited neighbours of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again.</p></li>
<li><p>If the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal; occurs when there is no connection between the initial node and remaining unvisited nodes), then stop. The algorithm has finished.</p></li>
<li><p>Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new “current node&quot;, and go back to step 3.</p></li>
</ol>
<p>The code for maintaining the visited set can be simplified by using a priority queue.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> collections <span class="im">import</span> defaultdict
<span class="im">from</span> heapq <span class="im">import</span> <span class="op">*</span>

<span class="kw">def</span> dijkstra(edges, f, t):
    g <span class="op">=</span> defaultdict(<span class="bu">list</span>)
    <span class="cf">for</span> l,r,c <span class="op">in</span> edges:
        g[l].append((c,r))

    q, seen, mins <span class="op">=</span> [(<span class="dv">0</span>,f,())], <span class="bu">set</span>(), {f: <span class="dv">0</span>}
    <span class="cf">while</span> q:
        (cost,v1,path) <span class="op">=</span> heappop(q)
        <span class="cf">if</span> v1 <span class="op">not</span> <span class="op">in</span> seen:
            seen.add(v1)
            path <span class="op">=</span> (v1, path)
            <span class="cf">if</span> v1 <span class="op">==</span> t: <span class="cf">return</span> (cost, path)

            <span class="cf">for</span> c, v2 <span class="op">in</span> g.get(v1, ()):
                <span class="cf">if</span> v2 <span class="op">in</span> seen: <span class="cf">continue</span>
                prev <span class="op">=</span> mins.get(v2, <span class="va">None</span>)
                <span class="bu">next</span> <span class="op">=</span> cost <span class="op">+</span> c
                <span class="cf">if</span> prev <span class="op">is</span> <span class="va">None</span> <span class="op">or</span> <span class="bu">next</span> <span class="op">&lt;</span> prev:
                    mins[v2] <span class="op">=</span> <span class="bu">next</span>
                    heappush(q, (<span class="bu">next</span>, v2, path))

    <span class="cf">return</span> <span class="bu">float</span>(<span class="st">&quot;inf&quot;</span>)</code></pre></div>
<h3 id="a">A*</h3>
<p>A* (pronounced “A-star&quot;) is a graph traversal and path search algorithm. It is a minor extension of Djikstra’s algorithm that builds in a heuristic for remaining distance used to indicate the relevance of paths which should be tried first.</p>
<p>One important aspect of A* is <span class="math inline">\(F = G + H\)</span>. The <span class="math inline">\(F\)</span>, <span class="math inline">\(G\)</span>, and <span class="math inline">\(H\)</span> variables are in our Node class and get calculated every time we create a new node.</p>
<ul>
<li><p><span class="math inline">\(F\)</span> is the total cost of the node.</p></li>
<li><p><span class="math inline">\(G\)</span> is the distance between the current node and the start node.</p></li>
<li><p><span class="math inline">\(H\)</span> is the heuristic — estimated distance from the current node to the end node.</p></li>
</ul>
<p>A major practical drawback is its <span class="math inline">\({\ensuremath{\mathcal{O}}}(b^d)\)</span> space complexity, as it stores all generated nodes in memory.</p>
<h2 id="graph-analysis-methods">Graph Analysis Methods</h2>
<h3 id="topological-sort">Topological Sort</h3>
<p>Time Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(|V| + |E|)\)</span> worst case, Space Complexity: <span class="math inline">\({\ensuremath{\mathcal{O}}}(|V|)\)</span></p>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge <span class="math inline">\(uv\)</span> from vertex <span class="math inline">\(u\)</span> to vertex <span class="math inline">\(v\)</span>, <span class="math inline">\(u\)</span> comes before <span class="math inline">\(v\)</span> in the ordering. A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a <strong>directed acyclic graph</strong> (DAG). Any DAG has at least one topological ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time.</p>
<p>An algorithm for topological sorting is based on depth-first search. Simply put, run DFS and output the reverse of the finishing times of vertices, where finishing time corresponds to number of steps taken by DFS. The algorithm loops through each node of the graph, in an arbitrary order, initiating a depth-first search that terminates when it hits any node that has already been visited since the beginning of the topological sort or the node has no outgoing edges (i.e. a leaf node). Each node <span class="math inline">\(n\)</span> gets prepended to the output list <span class="math inline">\(L\)</span> only after considering all other nodes which depend on <span class="math inline">\(n\)</span> (all descendants of <span class="math inline">\(n\)</span> in the graph). Specifically, when the algorithm adds node <span class="math inline">\(n\)</span>, we are guaranteed that all nodes which depend on <span class="math inline">\(n\)</span> are already in the output list <span class="math inline">\(L\)</span>: they were added to <span class="math inline">\(L\)</span> either by the recursive call to visit() which ended before the call to visit <span class="math inline">\(n\)</span>, or by a call to visit() which started even before the call to visit <span class="math inline">\(n\)</span>. Since each edge and node is visited once, the algorithm runs in linear time.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> collections <span class="im">import</span> deque
GRAY, BLACK <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span>

<span class="kw">def</span> topological_sort(graph):
    order, enter, state <span class="op">=</span> deque(), <span class="bu">set</span>(graph), {}

    <span class="kw">def</span> dfs(node):
        state[node] <span class="op">=</span> GRAY
        <span class="cf">for</span> k <span class="op">in</span> graph.get(node, ()):
            sk <span class="op">=</span> state.get(k, <span class="va">None</span>)
            <span class="cf">if</span> sk <span class="op">==</span> GRAY:
                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;cycle&quot;</span>)
            <span class="cf">if</span> sk <span class="op">==</span> BLACK:
                <span class="cf">continue</span>
            enter.discard(k)
            dfs(k)
        order.appendleft(node)
        state[node] <span class="op">=</span> BLACK

    <span class="cf">while</span> enter:
        dfs(enter.pop())
    <span class="cf">return</span> order</code></pre></div>
<h2 id="recursive-problems">Recursive Problems</h2>
<p>Although there is some overlap, recursive solutions can be thought of in terms of the following categories,</p>
<ul>
<li><p>Iteration – instead of iterating with a for loop, a recursive call stack is used to iterate over an array/list. This often simplifies the code.</p></li>
<li><p>Sub-problems – A catch-all for generic and classic recursion problems in which a solution to the larger problem can be derived from solutions of the sub-problems.</p></li>
<li><p>Selection – Problems that can be solved by finding all valid combinations of a set of inputs. A brute-force approach that finds all possible combinations and then validates based on the requirements of problem statement. Can be further optimized to continuously validate at every decision step, dropping invalid branches of combinations using backtracking or caching relevant computations using dynamic programming.</p></li>
<li><p>Ordering (Permutations) – Similar to selection but the ordering of the selections matters.</p></li>
<li><p>Divide and Conquer – Similar to sub-problems, but instead of solving for n sub-problems, we split the input into two halves and recursively validate the sub-problem dropping one half at each recursion. Commonly found in searching and sorting problems.</p></li>
<li><p>Depth-first search – A common technique used in tree/graph structures, where a recursive call is used instead of using stack ADT.</p></li>
</ul>
<p>A <strong>bottom-up</strong> approach is often the most intuitive recursive pattern. We start with knowing how to solve the problem for a simple case, like a list with only one element. Then we figure out how to solve the problem for two elements, then for three elements, and so on. The key here is to think about how you can build the solution for one case off of the previous case (or multiple previous cases).</p>
<p>The <strong>top-down</strong> approach can be more complex since it’s less concrete. But sometimes, it’s the best way to think about the problem. In these problems, we think about how we can divide the problem for case <span class="math inline">\(N\)</span> into subproblems. Be careful of overlap between the cases.</p>
<p><strong>Half-and-Half</strong> Approach. In addition to top-down and bottom-up approaches, it’s often effective to divide the data set in half. For example, binary search works with a “half-and-half” approach. When we look for an element in a sorted array, we first figure out which half of the array contains the value. Then we recurse and search for it in that half.</p>
<p>All recursive algorithms can be implemented iteratively, although sometimes the code to do so is much more complex. Drawing the recursive calls as a tree is a useful way to figure out the runtime of a recursive algorithm.</p>
<h3 id="greedy-algorithms">Greedy Algorithms</h3>
<p>A greedy algorithm, as the name suggests, always makes the choice that seems to be the best at that moment. This means that it makes a locally-optimal choice in the hope that this choice will lead to a globally-optimal solution. They never look backwards at what they’ve done to see if they could optimise globally. This is the main difference between Greedy and Dynamic Programming.</p>
<p>Even though a greedy algorithm follows the problem-solving heuristic of making the locally optimal choice at each stage with the intent of finding a global optimum, there are cases where locally optimal solutions or maxima are not the global optimal solution which will cause the algorithm to product incorrect solutions. Nonetheless a greedy heuristic may yield locally optimal solutions that approximate a globally optimal solution in a reasonable amount of time.</p>
<p>Greedy algorithms are only ideal for problems which have optimal substructure. A problem is said to have <strong>optimal substructure</strong> if an optimal solution can be constructed efficiently from optimal solutions of its subproblem. Typically, a greedy algorithm is used to solve a problem with optimal substructure if it can be proven by induction that it is optimal at each step. Otherwise, provided the problem exhibits overlapping subproblems, then dynamic programming is preferable. If there are no appropriate greedy algorithms and the problem fails to exhibit overlapping subproblems, often a lengthy but straightforward search of the solution space is the best alternative.</p>
<h3 id="backtracking">Backtracking</h3>
<p>Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons a candidate (“backtracks&quot;) as soon as it determines that the candidate cannot possibly be completed to a valid solution.</p>
<p>It is useful for exhaustive recursive problems in which the solution must follow some constraints. We may define a policy for recursion and when a computation does not meet the constraints, we halt or backtrack on the exhaustive recursion.</p>
<p>The call stack remembers our previous choices and decides what choice to make next.</p>
<p>Three key things to keep in mind</p>
<ol style="list-style-type: decimal">
<li><p>Our choice – What choice do we make at each call of the function? Recursion expresses this decision</p></li>
<li><p>Our constraints – When do we stop following a certain path?</p></li>
<li><p>Our goal – What’s our target? What are we trying to find?</p></li>
</ol>
<p>Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons a candidate as soon as it determines that the candidate cannot possibly be completed to a valid solution.</p>
<p>The difference between backtracking and depth-first search is that backtracking traverses in the solution space whereas DFS traverses in data structure space, pruned of DFS.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> backtracking(<span class="va">self</span>, data, candidate):
    <span class="co"># pruning</span>
    <span class="cf">if</span> <span class="va">self</span>.reject(data, candidate):
        <span class="cf">return</span>

    <span class="co"># reach the end</span>
    <span class="cf">if</span> <span class="va">self</span>.accept(data, candidate):
        <span class="cf">return</span> <span class="va">self</span>.output(data, candidate)

    <span class="co"># drill down</span>
    <span class="cf">for</span> cur_candidate <span class="op">in</span> <span class="va">self</span>.all_extension(data, candidate):
        <span class="co"># or you can choose to prune here, recursion depth - 1</span>
        <span class="cf">if</span> <span class="op">not</span> <span class="va">self</span>.should_to_be_pruned(cur_candidate):
            <span class="va">self</span>.backtracking(data, cur_candidate)</code></pre></div>
<h3 id="dynamic-programming-memoization">Dynamic Programming &amp; Memoization</h3>
<p>Dynamic programming (DP) is a general, powerful algorithm design technique. It is mostly just a matter of taking a recursive algorithm and finding the overlapping subproblems (that is, the repeated calls). You then cache those results for future recursive calls. Alternatively, you can study the pattern of the recursive calls and implement something iterative. You still cache previous work. A dynamical programming solution can only be used if the problem possesses the optimal substructure property, i.e. its global optimal solution can be constructed efficiently from optimal solutions of its subproblems.</p>
<p>A problem is said to have <strong>overlapping subproblems</strong> if the problem can be broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems. DP corresponds to a careful bruteforce approach, taking an exponential algorithm and making it polynomial. The basic idea of dynamic programming is to take a problem, split it into subproblems, solve the subproblems, and re-use the solutions to the subproblems.</p>
<p><strong>Memoization</strong> refers to the technique of caching and reusing previously computed results. Some people call top-down dynamic programming “memoization” and only use “dynamic programming” to refer to bottom-up work</p>
<p>A bottom-up solution uses <strong>tabulation</strong> to only store the relevant calls needed for future computations. With tabulation, we have to come up with an ordering which is often less intuitive than memoized solutions. If all sub-problems must be solved at least once, a bottom-up tabulated dynamic programming algorithm usually outperforms a top-down memoized algorithm by a constant factor.</p>
<p>A memoized function only recurses the first time it’s called with the memoized call costing <span class="math inline">\(\Theta(1)\)</span>. In general, the time complexity will be the number of subproblems needed to be solved multiplied by the running time per subproblem. We no longer need to count recursions or the call stack.</p>
<ol style="list-style-type: decimal">
<li><p>Define subproblems</p></li>
<li><p>Guess (part of the solution)</p></li>
<li><p>Relate subproblem solutions (with a recurrence)</p></li>
<li><p>Construct an algorithm by recursion and memoization (need acyclic DAG) or building a DP table bottom up (need topological order)</p></li>
<li><p>Solve original problem. Time = number of subproblems multiplied by running time/ subproblem</p></li>
</ol>
<p>Defining subproblems for strings, sequences:</p>
<ul>
<li><p>suffixes x[i:] for all i. <span class="math inline">\(\mathcal{O}(n)\)</span></p></li>
<li><p>prefixes x[:i] for all i. <span class="math inline">\(\mathcal{O}(n)\)</span></p></li>
<li><p>substrings x[i:j] for all <span class="math inline">\(i \leq j\)</span> <span class="math inline">\(\mathcal{O}(n^2)\)</span></p></li>
</ul>
<p>Topological order, i.e. order in which subproblems are executed, should be from smallest to largest.</p>
<p>Two kinds of guessing:</p>
<ul>
<li><p>Which subproblems to use to solve bigger subproblem.</p></li>
<li><p>Add more subproblems to guess, remember more features of the solution variations.</p></li>
</ul>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># It takes n steps to reach to the top of a set of stairs. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</span>

<span class="kw">def</span> climbStairs(n):
        dp <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>]
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):
            dp.append(dp[i<span class="dv">-1</span>] <span class="op">+</span> dp[i<span class="dv">-2</span>])
        <span class="cf">return</span> dp[n]

<span class="co"># Compute the fewest number of coins that are needed to sum to an amount</span>

<span class="kw">def</span> coinChange(coins, amount):
    MAX <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)
    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">+</span> [MAX] <span class="op">*</span> amount

    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, amount <span class="op">+</span> <span class="dv">1</span>):
        dp[i] <span class="op">=</span> <span class="bu">min</span>(dp[i <span class="op">-</span> c] <span class="cf">if</span> i <span class="op">-</span> c <span class="op">&gt;=</span> <span class="dv">0</span> <span class="cf">else</span> MAX <span class="cf">for</span> c <span class="op">in</span> coins) <span class="op">+</span> <span class="dv">1</span>

    <span class="cf">return</span> [dp[<span class="op">-</span><span class="dv">1</span>], <span class="op">-</span><span class="dv">1</span>][dp[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> MAX]

<span class="co"># Given a knapsack with a maximum weight capacity and a list of items with value and weights, maximize the amount of value we can fit within the knapsacks weight capacity.</span>

<span class="kw">def</span> knapsack(capacity, weight, values, n):
    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="op">or</span> capacity <span class="op">==</span> <span class="dv">0</span> :
        <span class="cf">return</span> <span class="dv">0</span>
    <span class="co"># If weight is higher than capacity then it is not included</span>
    <span class="cf">if</span> (weight[n<span class="dv">-1</span>] <span class="op">&gt;</span> capacity):
        <span class="cf">return</span> knapsack(capacity, weight, values, n<span class="dv">-1</span>)
    <span class="co"># return either nth item being included or not</span>
    <span class="cf">else</span>:
        <span class="cf">return</span> <span class="bu">max</span>(
            values[n<span class="dv">-1</span>] <span class="op">+</span> knapsack(capacity<span class="op">-</span>weight[n<span class="dv">-1</span>], weight, values, n<span class="dv">-1</span>),
            knapsack(capacity, weight, values, n<span class="dv">-1</span>)


<span class="co"># Given an unsorted array of integers, find the length of longest increasing subsequence.</span>

<span class="kw">def</span> lengthOfLIS(nums):
    n <span class="op">=</span> <span class="bu">len</span>(nums)
    <span class="cf">if</span> <span class="op">not</span> n: <span class="cf">return</span> <span class="dv">0</span>
    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n

    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):
        <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(i):
            <span class="cf">if</span> nums[i] <span class="op">&gt;</span> nums[j]:
                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j]<span class="op">+</span><span class="dv">1</span>)

    <span class="cf">return</span> <span class="bu">max</span>(dp)

<span class="co"># Given two strings text1 and text2, return the length of their longest common subsequence.</span>

<span class="im">import</span> functools

<span class="kw">def</span> longestCommonSubsequence(text1: <span class="bu">str</span>, text2: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:

    <span class="co">## similar to memoization, in recursive calls the decorator doesn&#39;t have to recompute but retrieves from the cache</span>
    <span class="at">@functools.lru_cache</span>(<span class="va">None</span>)
    <span class="kw">def</span> helper(i,j):
        <span class="cf">if</span> i<span class="op">&lt;</span><span class="dv">0</span> <span class="op">or</span> j<span class="op">&lt;</span><span class="dv">0</span>:
            <span class="cf">return</span> <span class="dv">0</span>
        <span class="cf">if</span> text1[i]<span class="op">==</span>text2[j]:
            <span class="cf">return</span> helper(i<span class="dv">-1</span>,j<span class="dv">-1</span>)<span class="op">+</span><span class="dv">1</span>
        <span class="cf">return</span> <span class="bu">max</span>(helper(i<span class="dv">-1</span>,j),helper(i,j<span class="dv">-1</span>))
    <span class="cf">return</span> helper(<span class="bu">len</span>(text1)<span class="op">-</span><span class="dv">1</span>,<span class="bu">len</span>(text2)<span class="op">-</span><span class="dv">1</span>)</code></pre></div>
<h2 id="numerical-problems">Numerical Problems</h2>
<h3 id="bit-manipulation">Bit Manipulation</h3>
<p>Bit manipulation is the act of algorithmically manipulating bits or other pieces of data shorter than a word. Computer programming tasks that require bit manipulation include low-level device control, error detection and correction algorithms, data compression, encryption algorithms, and optimization. For most other tasks, modern programming languages allow the programmer to work directly with abstractions instead of bits that represent those abstractions. Source code that does bit manipulation makes use of the bitwise operations: AND, OR, XOR, NOT, and bit shifts.</p>
<p>Bit manipulation, in some cases, can obviate or reduce the need to loop over a data structure and can give many-fold speed ups, as bit manipulations are processed in parallel, but the code can become more difficult to write and maintain.</p>
<p>At the heart of bit manipulation are the bit-wise operators</p>
<ul>
<li><p>&amp; (and)</p></li>
<li><p><span class="math inline">\(\vert\)</span> (or)</p></li>
<li><p><span class="math inline">\(\sim\)</span> (not)</p></li>
<li><p><span class="math inline">\(\wedge\)</span> (exclusive-or, xor)</p></li>
<li><p>a <span class="math inline">\(&lt;&lt;\)</span> b, a <span class="math inline">\(&gt;&gt;\)</span> b (shift operators)</p></li>
</ul>
<p>The exclusive-or operation takes two inputs and returns a 1 if either one or the other of the inputs is a 1, but not if both are. That is, if both inputs are 1 or both inputs are 0, it returns 0. Bitwise exclusive-or, with the operator of a caret, performs the exclusive-or operation on each pair of bits. Exclusive-or is commonly abbreviated XOR.</p>
<ul>
<li><p>Set union: <span class="math inline">\(A \vert B\)</span></p></li>
<li><p>Set intersection: <span class="math inline">\(A \And B\)</span></p></li>
<li><p>Set subtraction: <span class="math inline">\(A \And \sim B\)</span></p></li>
<li><p>Set negation: <span class="math inline">\(\text{ALL BITS } \wedge A\)</span> or <span class="math inline">\(\sim A\)</span></p></li>
<li><p>Set bit: <span class="math inline">\(A \vert= 1 &lt;&lt; \text{bit}\)</span></p></li>
<li><p>Clear bit: <span class="math inline">\(A \And = \sim (1 &lt;&lt; \text{bit})\)</span></p></li>
<li><p>Test bit: <span class="math inline">\((A \&amp; 1 &lt;&lt; \text{bit}) != 0\)</span></p></li>
<li><p>Extract last bit: <span class="math inline">\(A\And-A\)</span> or <span class="math inline">\(A \And \sim (A-1)\)</span> or <span class="math inline">\(x\wedge (x \And (x -1))\)</span></p></li>
<li><p>Remove last bit: <span class="math inline">\(A \And (A-1)\)</span></p></li>
<li><p>Get all 1-bits: <span class="math inline">\(\sim 0\)</span></p></li>
</ul>
<p>Two’s complement is a mathematical operation on binary numbers, and is an example of a radix complement. It is used in computing as a method of signed number representation. The two’s complement of an N-bit number is defined as its complement with respect to <span class="math inline">\(2^N\)</span>. For instance, for the three-bit number 010, the two’s complement is 110, because 010 + 110 = 1000. The two’s complement is calculated by inverting the digits and adding one.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> operator

<span class="co"># Given an array containing n distinct numbers taken from [0, n], find the one that is missing from the array.</span>

<span class="kw">def</span> missingNumber(<span class="va">self</span>, nums):
    <span class="cf">return</span> <span class="bu">reduce</span>(operator.xor, nums <span class="op">+</span> <span class="bu">range</span>(<span class="bu">len</span>(nums)<span class="op">+</span><span class="dv">1</span>))</code></pre></div>
<h2 id="combinatorial-problems">Combinatorial Problems</h2>
<p>View combinatorics notebook<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> for more details.</p>
<h3 id="permuations">Permuations</h3>
<ol style="list-style-type: decimal">
<li><p>Order of items matters.</p></li>
<li><p>Counts do not include duplication or removals of items.</p></li>
<li><p>Collection of counts could be stored in <em>arrays</em>.</p></li>
</ol>
<p><span class="math display">\[P(n,m) = \frac{n!}{(n-m)!}\]</span></p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> itertools <span class="im">import</span> permutations 

<span class="co"># Get all permutations of [1, 2, 3] </span>
perm <span class="op">=</span> permutations([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])   

<span class="co"># Get all permutations of length 2 </span>
perm <span class="op">=</span> permutations([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], <span class="dv">2</span>) </code></pre></div>
<h3 id="combinations">Combinations</h3>
<ol style="list-style-type: decimal">
<li><p>Order of items doesn’t matter.</p></li>
<li><p>Counts do not include duplication or removals of items.</p></li>
<li><p>Collection of counts could be stored in <em>sets</em>.</p></li>
</ol>
<p><span class="math display">\[\binom{n+1}{k} = \binom{n}{k} + \binom{n}{k+1}\]</span></p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> itertools

<span class="co"># Get all combinations of [1, 2, 3] of length 2 </span>
comb <span class="op">=</span> itertools.combinations([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], <span class="dv">2</span>)

<span class="co"># Get all combinations with an element-to-itself combination included </span>
comb <span class="op">=</span> itertools.combinations_with_replacement([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</code></pre></div>
<h3 id="n-th-partial-sum">n-th Partial Sum</h3>
<p>This counting formula can be used to count the number of contiguous substrings in a a string or contiguous subarrays in an array. <span class="math display">\[\sum_{k=1}^n k = 1 + 2 + 3 + \cdots + n = \frac{n(n+1)}{2}\]</span></p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python">n <span class="op">=</span> <span class="dv">10</span>
nth_partial_sum <span class="op">=</span> (n <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)) <span class="op">/</span> <span class="dv">2</span> 
iterative_sum_count <span class="op">=</span> <span class="bu">sum</span>([i <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>)])
contiguous_sublists <span class="op">=</span> <span class="kw">lambda</span> l: [
    l[m: n <span class="op">+</span> <span class="dv">1</span>] 
    <span class="cf">for</span> m <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(l)) 
    <span class="cf">for</span> n <span class="op">in</span> <span class="bu">range</span>(m, <span class="bu">len</span>(l))
]
contiguous_sublist_count <span class="op">=</span> <span class="bu">len</span>(contiguous_sublists([<span class="dv">0</span>] <span class="op">*</span> n ))

<span class="cf">assert</span> iterative_sum_count <span class="op">==</span> nth_partial_sum <span class="op">==</span> contiguous_sublist_count</code></pre></div>
<h3 id="lattice-paths">Lattice Paths</h3>
<p>A sequence of ordered pairs <span class="math inline">\((m_1, n_1), (m_2, n_2), \cdots, (m_t, n_t)\)</span> such that either:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(m_{i+1} = m_{i}+1\)</span> and <span class="math inline">\(n_{i+1} = n_{i}\)</span></p></li>
<li><p><span class="math inline">\(m_{i+1} = m_i\)</span> and <span class="math inline">\(n_{i+1} = n_i +1\)</span>.</p></li>
</ol>
<p>The construction of lattice paths forms a bijection with <span class="math inline">\(X\)</span>-strings where <span class="math inline">\(X = \{ H, V\}\)</span> with <span class="math inline">\(H,V\)</span> encoding horizontal or vertical moves on a grid. The number of lattice paths from <span class="math inline">\((m_1, n_1)\)</span> to <span class="math inline">\((m_2,n_2)\)</span> is, <span class="math display">\[\binom{m_2 - m_1 + m_2 - m_1}{m_2-m_1}.\]</span></p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> math

<span class="kw">def</span> unique_paths(m, n):
    <span class="cf">if</span> <span class="op">not</span> m <span class="op">or</span> <span class="op">not</span> n: <span class="cf">return</span> <span class="dv">0</span>
    <span class="cf">return</span> math.factorial(m <span class="op">+</span> n <span class="op">-</span> <span class="dv">2</span>)<span class="op">/</span>(math.factorial(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> math.factorial(m <span class="op">-</span> <span class="dv">1</span>))</code></pre></div>
<h3 id="stars-and-bars">Stars and bars</h3>
<p>The number of ways to put <span class="math inline">\(n\)</span> identical objects into <span class="math inline">\(k\)</span> labeled boxes is, <span class="math display">\[\binom{n+k-1}{n}.\]</span></p>
<p>We can use this for various counting problems, i.e the number of non-negative integer sums, the number of lower-bound integer sums, etc.</p>
<p><em>Python Implementation</em></p>
<div class="sourceCode" language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> itertools

<span class="kw">def</span> stars_and_bars(n, k):
    <span class="cf">for</span> c <span class="op">in</span> itertools.combinations(<span class="bu">range</span>(n<span class="op">+</span>k<span class="dv">-1</span>), k<span class="dv">-1</span>):
        <span class="cf">yield</span> [b<span class="op">-</span>a<span class="dv">-1</span> <span class="cf">for</span> a, b <span class="op">in</span> <span class="bu">zip</span>((<span class="op">-</span><span class="dv">1</span>,)<span class="op">+</span>c, c<span class="op">+</span>(n<span class="op">+</span>k<span class="dv">-1</span>,))]</code></pre></div>
<p>Steven S. Skiena. 2008. The Algorithm Design Manual (2nd. ed.). Springer Publishing Company, Incorporated.</p>
<p>Erik Demaine, Srini Devadas. Introduction to Algorithms. Fall 2011. Massachusetts Institute of Technology: MIT OpenCouseWare, https://ocw.mit.edu/. License: Creative Commons</p>
<p>David Liu, Data Structures and Analysis: Lecture Notes for CSC263, Department of Computer Science, University of Toronto</p>
<p>McDowell, Gayle Laakmann, Cracking The Coding Interview: 150 Programming Questions and Solutions. Palo Alto, CA :CareerCup, LLC, 2011.</p>
<p>Keller, M.T. and Trotter, W.T., Applied Combinatorics, Open Textbook Library, ISBN9781534878655.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>https://github.com/lukepereira/latex-ci<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</body>
</html>
